/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel-plugin for production.
 */
const documents = {
    "\n      query GET_INBOXES($filter: inboxes_bool_exp, $offset: Int = 0, $limit: Int = 20) {\n        total: inboxes_aggregate(where: $filter) {\n          aggregate {\n            count\n          }\n        }\n        payload: inboxes(where: $filter, offset: $offset, limit: $limit, order_by: { id: asc }) {\n          id\n          name\n          channel_type\n          channel_id\n          channel\n          description\n          is_enabled\n          created_at\n          updated_at\n          reply_channel_id\n          total_conversations: conversations_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    ": types.GET_INBOXESDocument,
    "\n      query GET_INBOXES_BY_ID($id: Int!) {\n        payload: inboxes_by_pk(id: $id) {\n          id\n          name\n          reply_channel_id\n          channel_type\n          channel\n        }\n      }\n    ": types.GET_INBOXES_BY_IDDocument,
    "\n      mutation UPDATE_INBOXES_BY_ID($id: Int!, $updated_values: inboxes_set_input = {}) {\n        payload: update_inboxes_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          name\n          is_enabled\n        }\n      }\n    ": types.UPDATE_INBOXES_BY_IDDocument,
    "\n      mutation UPDATE_EMAIL_INBOX_BY_ID($inbox_id: Int!, $channel_id: Int!, $inbox_update_values: inboxes_set_input = {}, $channel_update_values: channel_email_set_input = {}) {\n        updated_inbox: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n        updated_channel: update_channel_email_by_pk(pk_columns: { id: $channel_id }, _set: $channel_update_values) {\n          id\n          imap_enabled\n          imap_username\n          imap_host_address\n          imap_port\n          smtp_enabled\n          smtp_username\n          smtp_host_address\n          smtp_port\n          smtp_requires_ssl\n          updated_at\n          smtp_email\n          imap_password\n          smtp_password\n        }\n      }\n    ": types.UPDATE_EMAIL_INBOX_BY_IDDocument,
    "\n      mutation UPDATE_WHATSAPP_INBOX_BY_ID(\n        $inbox_id: Int!\n        $channel_id: bigint!\n        $inbox_update_values: inboxes_set_input = {}\n        $channel_update_values: channel_whatsapp_set_input = {}\n      ) {\n        updated_inbox: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n        updated_channel: update_channel_whatsapp_by_pk(pk_columns: { id: $channel_id }, _set: $channel_update_values) {\n          id\n          phone_number\n          phone_number_id\n          business_account_id\n          access_token\n        }\n      }\n    ": types.UPDATE_WHATSAPP_INBOX_BY_IDDocument,
    "\n      mutation DELETE_INBOX_BY_ID($inboxId: Int!) {\n        payload: delete_inboxes_by_pk(id: $inboxId) {\n          id\n          name\n          channel_type\n          channel_id\n        }\n      }\n    ": types.DELETE_INBOX_BY_IDDocument,
    "\n      query GET_CONVERSATION_LIST($where: conversations_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc) {\n        payload: conversations(where: $where, offset: $offset, limit: 10, order_by: { messages_aggregate: { max: { created_at: $created_at } } }) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n            channel\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(limit: 1, order_by: { created_at: desc }, where: { message_type: { _neq: 2 } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            conversation {\n              inbox {\n                channel\n              }\n            }\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    ": types.GET_CONVERSATION_LISTDocument,
    "\n      query GET_CONVERSATION_COUNTS($_and: [conversations_bool_exp!] = {}) {\n        mine: conversations_aggregate(where: { tab_type: { _contains: \"mine\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        pending: conversations_aggregate(where: { tab_type: { _contains: \"pending\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        watching: conversations_aggregate(where: { tab_type: { _contains: \"watching\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        history: conversations_aggregate(where: { tab_type: { _contains: \"history\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: conversations_aggregate(where: { tab_type: { _contains: \"unassigned\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    ": types.GET_CONVERSATION_COUNTSDocument,
    "\n    subscription GET_SUBSCRIPTION_CONVERSATION_COUNT($where: conversations_bool_exp = {}) {\n      payload: conversations_aggregate(where: $where) {\n        aggregate {\n          count\n        }\n      }\n    }\n  ": types.GET_SUBSCRIPTION_CONVERSATION_COUNTDocument,
    "\n    subscription GET_CONVERSATIONS_SUBSCRIPTION($where: conversations_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc) {\n      payload: conversations(where: $where, offset: $offset, limit: 1, order_by: { messages_aggregate: { max: { created_at: $created_at } } }) {\n        id\n      }\n    }\n  ": types.GET_CONVERSATIONS_SUBSCRIPTIONDocument,
    "\n      query GET_CONVERSATION_BY_ID($conversationId: bigint!) {\n        payload: conversations_by_pk(id: $conversationId) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          created_at\n          closing_contact_reason_value\n          additional_attributes\n          contact {\n            id\n            name\n            email\n            phone_number\n            preferred_language\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          agent {\n            id\n            name\n            display_name\n            email\n          }\n          inbox {\n            name\n            channel\n            reply_channel {\n              id\n              screen_name\n            }\n            team_inboxes {\n              team {\n                id\n                name\n              }\n            }\n          }\n          conversation_tags {\n            tag {\n              id\n              name\n              color\n            }\n          }\n          assigned_team_member {\n            team {\n              id\n              name\n            }\n            user {\n              id\n              name\n            }\n          }\n        }\n      }\n    ": types.GET_CONVERSATION_BY_IDDocument,
    "\n      query GET_FILTERED_CONVERSATION($search_content: String = \"%%\", $where: conversations_bool_exp) {\n        payload: conversations(limit: 10, order_by: { messages_aggregate: { max: { created_at: desc } } }, offset: 0, where: $where) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(order_by: { id: desc }, where: { message: { _ilike: $search_content }, message_type: { _in: [0, 1] } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            conversation {\n              inbox {\n                channel\n              }\n            }\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    ": types.GET_FILTERED_CONVERSATIONDocument,
    "\n      query GET_CONVERSATION_BY_CONTACT_ID($contact_id: Int!) {\n        payload: conversations(where: { contact_id: { _eq: $contact_id }, inbox_id: { _is_null: false } }) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n            channel\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(order_by: { id: desc }, limit: 1, where: { message_type: { _neq: 2 } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n          account {\n            name\n          }\n          conversation_tags {\n            tag {\n              id\n              name\n              color\n            }\n          }\n          agent {\n            name\n          }\n          assigned_team_member {\n            user {\n              name\n              id\n            }\n          }\n        }\n      }\n    ": types.GET_CONVERSATION_BY_CONTACT_IDDocument,
    "\n      query GET_CUSTOM_FILTERS($type: Int!) {\n        payload: custom_filters(where: { filter_type: { _eq: $type } }) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    ": types.GET_CUSTOM_FILTERSDocument,
    "\n      query GET_CUSTOM_FILTER_BY_ID($id: bigint!) {\n        payload: custom_filters_by_pk(id: $id) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    ": types.GET_CUSTOM_FILTER_BY_IDDocument,
    "\n      mutation CREATE_CUSTOM_FILTER($object: custom_filters_insert_input = {}) {\n        payload: insert_custom_filters_one(object: $object) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    ": types.CREATE_CUSTOM_FILTERDocument,
    "\n      mutation UPDATE_CUSTOM_FILTER_BY_ID($id: bigint!, $set: custom_filters_set_input = {}) {\n        payload: update_custom_filters_by_pk(pk_columns: { id: $id }, _set: $set) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    ": types.UPDATE_CUSTOM_FILTER_BY_IDDocument,
    "\n      mutation DELETE_CUSTOM_FILTER_BY_ID($id: bigint = \"\") {\n        payload: delete_custom_filters_by_pk(id: $id) {\n          id\n          name\n        }\n      }\n    ": types.DELETE_CUSTOM_FILTER_BY_IDDocument,
    "\n      query GET_MESSAGES($conversationId: bigint!, $offset: Int) {\n        payload: messages(where: { conversation_id: { _eq: $conversationId } }, limit: 10, order_by: { created_at: desc }, offset: $offset) {\n          id\n          message\n          message_type\n          conversation_id\n          created_at\n          internal\n          content_attributes\n          approved_at\n          source_id\n          sender_id\n          sender_info\n          attachments {\n            id\n            key\n            file_name\n            file_type\n            extension\n            url\n          }\n          reply_of_message {\n            id\n            message\n          }\n          conversation {\n            type\n            inbox {\n              name\n              channel_type\n              channel\n            }\n            contact {\n              id\n              name\n              email\n              phone_number\n              profile_image: source(path: \"profile_image\")\n              source\n              created_at\n              updated_at\n            }\n          }\n        }\n      }\n    ": types.GET_MESSAGESDocument,
    "\n    subscription GET_MESSAGES_SUBSCRIPTION($conversationId: bigint!) {\n      payload: messages(where: { conversation_id: { _eq: $conversationId } }, limit: 1, order_by: { created_at: desc }) {\n        id\n      }\n    }\n  ": types.GET_MESSAGES_SUBSCRIPTIONDocument,
    "\n    subscription GET_MESSAGES_COUNT_BY_CONVERSATION_ID($conversationId: bigint = 10) {\n      payload: messages_aggregate(where: { conversation_id: { _eq: $conversationId } }) {\n        aggregate {\n          count\n        }\n      }\n    }\n  ": types.GET_MESSAGES_COUNT_BY_CONVERSATION_IDDocument,
    "\n      mutation READ_MESSAGES($conversation_id: bigint!) {\n        payload: update_messages(where: { conversation_id: { _eq: $conversation_id }, status: { _eq: 1 } }, _set: { status: 0 }) {\n          returning {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    ": types.READ_MESSAGESDocument,
    "\n      query GET_AGENT_LIST($where: account_agents_bool_exp = {}, $offset: Int = 0, $limit: Int = 20) {\n        total: account_agents_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: account_agents(limit: $limit, offset: $offset, order_by: { id: desc }, where: $where) {\n          id\n          name\n          phone_number\n          email\n          avatar_url\n          role\n          is_enabled\n          verified\n          team_list: team_members {\n            team {\n              id\n              name\n            }\n            user_id\n          }\n        }\n      }\n    ": types.GET_AGENT_LISTDocument,
    "\n      query GET_AGENT_BY_ID($user_id: bigint!) {\n        payload: account_agents(where: { id: { _eq: $user_id } }) {\n          id\n          name\n          role\n          email\n          phone_number\n          verified\n          invited_by {\n            id\n            name\n          }\n          team_members {\n            team {\n              id\n              name\n              is_enabled\n            }\n          }\n        }\n      }\n    ": types.GET_AGENT_BY_IDDocument,
    "\n      mutation UPDATE_AGENT($agent_id: bigint!, $set_account_users: account_users_set_input = {}, $set_user: users_set_input = {}) {\n        account_users: update_account_users(where: { user_id: { _eq: $agent_id } }, _set: $set_account_users) {\n          returning {\n            id\n          }\n        }\n        user: update_users_by_pk(pk_columns: { id: $agent_id }, _set: $set_user) {\n          id\n        }\n      }\n    ": types.UPDATE_AGENTDocument,
    "\n      mutation UPDATE_AGENT_STATUS($agent_id: bigint!, $is_enabled: Boolean!) {\n        payload: update_account_users(where: { user_id: { _eq: $agent_id } }, _set: { is_enabled: $is_enabled }) {\n          returning {\n            user_id\n            is_enabled\n          }\n        }\n      }\n    ": types.UPDATE_AGENT_STATUSDocument,
    "\n      mutation DELETE_AGENT_BY_ID($agent_id: bigint!) {\n        payload: delete_account_users(where: { user_id: { _eq: $agent_id } }) {\n          returning {\n            id\n          }\n        }\n      }\n    ": types.DELETE_AGENT_BY_IDDocument,
    "\n      query GET_TEAMS($filter: teams_bool_exp, $offset: Int = 0, $limit: Int = 20) {\n        payload: teams(where: $filter, order_by: { id: asc }, limit: $limit, offset: $offset) {\n          id\n          name\n          type\n          description\n          is_enabled\n          team_members {\n            id\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n        total: teams_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    ": types.GET_TEAMSDocument,
    "\n      query GET_TEAM_BY_MEMBER_ID($agent_id: bigint!, $conversation_id: bigint!) {\n        payload: teams(where: { team_members: { user_id: { _eq: $agent_id } }, team_inboxes: { inbox: { conversations: { id: { _eq: $conversation_id } } } } }) {\n          id\n          name\n          is_enabled\n          allow_auto_assign\n        }\n      }\n    ": types.GET_TEAM_BY_MEMBER_IDDocument,
    "\n      query GET_TEAM_BY_USER_ID($user_id: bigint!) {\n        payload: teams(where: { team_members: { user_id: { _eq: $user_id } } }) {\n          id\n          name\n        }\n      }\n    ": types.GET_TEAM_BY_USER_IDDocument,
    "\n      mutation CREATE_TEAM($object: teams_insert_input!) {\n        payload: insert_teams_one(object: $object) {\n          id\n          name\n          description\n          is_enabled\n          type\n          team_members {\n            id\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    ": types.CREATE_TEAMDocument,
    "\n      mutation DELETE_TEAM($team_id: bigint!) {\n        payload: delete_teams_by_pk(id: $team_id) {\n          id\n          name\n          type\n          description\n          is_enabled\n          team_members {\n            id\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    ": types.DELETE_TEAMDocument,
    "\n      mutation UPDATE_TEAM_BY_ID(\n        $team_id: bigint!\n        $set: teams_set_input!\n        $member_ids: [bigint!]\n        $inserted_team_members: [team_members_insert_input!]!\n        $inbox_ids: [bigint!]\n        $inserted_team_inboxes: [team_inboxes_insert_input!]!\n      ) {\n        deleted_team_members: delete_team_members(where: { team_id: { _eq: $team_id }, user_id: { _nin: $member_ids } }) {\n          returning {\n            team_id\n            user_id\n          }\n        }\n        inserted_team_members: insert_team_members(\n          objects: $inserted_team_members\n          on_conflict: { constraint: team_members_team_id_user_id_key, update_columns: [approval_enabled, auto_assign_enabled, max_conversation_queue] }\n        ) {\n          returning {\n            team_id\n            user_id\n          }\n        }\n        deleted_team_inboxes: delete_team_inboxes(where: { team_id: { _eq: $team_id }, inbox_id: { _nin: $inbox_ids } }) {\n          returning {\n            team_id\n            inbox_id\n          }\n        }\n        inserted_team_inboxes: insert_team_inboxes(objects: $inserted_team_inboxes, on_conflict: { constraint: team_inboxes_team_id_inbox_id_key, update_columns: [] }) {\n          returning {\n            team_id\n            inbox_id\n          }\n        }\n        updated_team: update_teams_by_pk(pk_columns: { id: $team_id }, _set: $set) {\n          id\n          name\n          type\n          is_enabled\n          team_members {\n            team_id\n            user_id\n            approval_enabled\n            auto_assign_enabled\n            max_conversation_queue\n          }\n        }\n      }\n    ": types.UPDATE_TEAM_BY_IDDocument,
    "\n      query GET_TEAM_BY_ID($team_id: bigint!) {\n        payload: teams_by_pk(id: $team_id) {\n          id\n          name\n          type\n          description\n          is_enabled\n          allow_auto_assign\n          team_members {\n            user {\n              id\n              name\n            }\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n          }\n          team_inboxes {\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    ": types.GET_TEAM_BY_IDDocument,
    "\n      mutation ADD_TEAM_MEMBERS($objects: [team_members_insert_input!] = {}) {\n        payload: insert_team_members(objects: $objects, on_conflict: { constraint: team_members_team_id_user_id_key, update_columns: [] }) {\n          returning {\n            id\n            team_id\n            user_id\n          }\n        }\n      }\n    ": types.ADD_TEAM_MEMBERSDocument,
    "\n      mutation DELETE_TEAM_MEMBER($members: [bigint!]) {\n        payload: delete_team_members(where: { user_id: { _in: $members } }) {\n          affected_rows\n          returning {\n            id\n          }\n        }\n      }\n    ": types.DELETE_TEAM_MEMBERDocument,
    "\n      query GET_TEAM_MEMBERS_BY_TEAM_ID($team_id: bigint!, $is_enabled: account_users_bool_exp, $mine_id: bigint_comparison_exp) {\n        payload: team_members(where: { team_id: { _eq: $team_id }, user: { account_users: $is_enabled, id: $mine_id } }) {\n          agent: user {\n            id\n            name\n            display_name\n            email\n          }\n        }\n      }\n    ": types.GET_TEAM_MEMBERS_BY_TEAM_IDDocument,
    "\n      query GET_TEAM_MEMBERS_BY_INBOX_ID($inbox_id: bigint!) {\n        payload: teams(where: { is_enabled: { _eq: true }, team_inboxes: { inbox_id: { _eq: $inbox_id } } }) {\n          id\n          name\n          team_members(where: { agent: { is_enabled: { _eq: true } } }) {\n            team_id\n            user_id\n            user {\n              name\n              account_users {\n                availability\n              }\n            }\n            max_conversation_queue\n            total_conversations: conversations_aggregate(where: { inbox_id: { _eq: $inbox_id } }) {\n              aggregate {\n                count\n              }\n            }\n          }\n        }\n      }\n    ": types.GET_TEAM_MEMBERS_BY_INBOX_IDDocument,
    "\n      mutation ASSIGN_TEAM_TO_INBOX($objects: [team_inboxes_insert_input!] = {}) {\n        payload: insert_team_inboxes(objects: $objects, on_conflict: { constraint: team_inboxes_team_id_inbox_id_key, update_columns: [] }) {\n          returning {\n            id\n            team_id\n            inbox_id\n          }\n        }\n      }\n    ": types.ASSIGN_TEAM_TO_INBOXDocument,
    "\n      mutation ASSIGN_AGENT_TO_CONVERSATION($conversation_id: bigint!, $agent_id: bigint!, $team_id: bigint!) {\n        payload: update_conversations_by_pk(pk_columns: { id: $conversation_id }, _set: { agent_id: $agent_id, assigned_team_id: $team_id }) {\n          id\n          assigned_team_member {\n            team {\n              id\n              name\n            }\n            user {\n              id\n              name\n            }\n          }\n        }\n      }\n    ": types.ASSIGN_AGENT_TO_CONVERSATIONDocument,
    "\n      query GET_ALL_CANNED_RESPONSES($search_content: String = \"\", $offset: Int = 0, $limit: Int = 20) {\n        total: canned_responses_aggregate(where: { _or: [{ short_code: { _ilike: $search_content } }, { content: { _ilike: $search_content } }] }) {\n          aggregate {\n            count\n          }\n        }\n        payload: canned_responses(where: { _or: [{ short_code: { _ilike: $search_content } }, { content: { _ilike: $search_content } }] }, offset: $offset, limit: $limit) {\n          id\n          short_code\n          content\n          content_html\n          use_count\n          is_enabled\n          category {\n            id\n            name\n          }\n          created_by {\n            name\n            id\n          }\n          created_at\n          updated_at\n        }\n      }\n    ": types.GET_ALL_CANNED_RESPONSESDocument,
    "\n      mutation DELETE_CANNED_RESPONSES_BY_ID($id: Int!) {\n        payload: delete_canned_responses_by_pk(id: $id) {\n          id\n        }\n      }\n    ": types.DELETE_CANNED_RESPONSES_BY_IDDocument,
    "\n      mutation CREATE_CANNED_RESPONSES($object: canned_responses_insert_input = {}) {\n        payload: insert_canned_responses_one(object: $object) {\n          id\n          short_code\n          content\n          use_count\n          is_enabled\n          category {\n            id\n            name\n          }\n          created_at\n          updated_at\n        }\n      }\n    ": types.CREATE_CANNED_RESPONSESDocument,
    "\n      mutation UPDATED_CANNED_RESPONSES_BY_ID($id: Int!, $updated_values: canned_responses_set_input = {}) {\n        payload: update_canned_responses_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          short_code\n          content\n          content_html\n          is_enabled\n          updated_at\n        }\n      }\n    ": types.UPDATED_CANNED_RESPONSES_BY_IDDocument,
    "\n      query GET_All_CANNED_RESPONSE_CATEGORIES(\n        $limit: Int = 20\n        $offset: Int = 0\n        $order_by: [canned_responses_category_order_by!] = {}\n        $where: canned_responses_category_bool_exp = {}\n      ) {\n        total: canned_responses_category_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: canned_responses_category(limit: $limit, offset: $offset, order_by: $order_by, where: $where) {\n          id\n          name\n          language\n          is_enabled\n          created_at\n          updated_at\n          created_by {\n            name\n            id\n          }\n        }\n      }\n    ": types.GET_All_CANNED_RESPONSE_CATEGORIESDocument,
    "\n      mutation CREATE_CANNED_CATEGORY($name: String!, $lang: String!) {\n        payload: insert_canned_responses_category_one(object: { name: $name, language: $lang }) {\n          id\n          language\n          name\n          is_enabled\n          created_at\n          updated_at\n        }\n      }\n    ": types.CREATE_CANNED_CATEGORYDocument,
    "\n      mutation UPDATE_CANNED_CATEGORY_by_ID($id: bigint!, $updated_values: canned_responses_category_set_input = {}) {\n        payload: update_canned_responses_category_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n          is_enabled\n          updated_at\n        }\n      }\n    ": types.UPDATE_CANNED_CATEGORY_by_IDDocument,
    "\n      mutation DELETE_CANNED_CATEGORY_BY_ID($id: bigint!) {\n        payload: delete_canned_responses_category_by_pk(id: $id) {\n          id\n        }\n      }\n    ": types.DELETE_CANNED_CATEGORY_BY_IDDocument,
    "\n      mutation DELETE_CONTACTS($contact_id: Int!) {\n        payload: delete_contacts_by_pk(id: $contact_id) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n        }\n      }\n    ": types.DELETE_CONTACTSDocument,
    "\n      mutation UPDATE_CONTACT($id: Int!, $set: contacts_set_input = {}) {\n        payload: update_contacts_by_pk(pk_columns: { id: $id }, _set: $set) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          city\n          gender\n          preferred_language\n          social_profiles\n        }\n      }\n    ": types.UPDATE_CONTACTDocument,
    "\n      mutation UPDATE_CONVERSATION_STATUS($conversation_id: bigint!, $updated_status: conversations_set_input = {}) {\n        payload: update_conversations_by_pk(pk_columns: { id: $conversation_id }, _set: $updated_status) {\n          id\n          status\n          closing_contact_reason_value\n        }\n      }\n    ": types.UPDATE_CONVERSATION_STATUSDocument,
    "\n      mutation DELETE_CONVERSATION_TAG_BY_ID($tag_id: bigint!, $conversation_id: bigint!) {\n        payload: delete_conversation_tags(where: { tag_id: { _eq: $tag_id }, conversation_id: { _eq: $conversation_id } }) {\n          affected_rows\n        }\n      }\n    ": types.DELETE_CONVERSATION_TAG_BY_IDDocument,
    "\n      mutation SEND_NOTE_WITH_CONVERSATION_CLOSE($message: String = \"\", $message_type: Int = 10, $conversation_id: bigint = \"\") {\n        payload: insert_messages_one(object: { message: $message, message_type: $message_type, conversation_id: $conversation_id }) {\n          message\n          conversation {\n            id\n          }\n          message_type\n        }\n      }\n    ": types.SEND_NOTE_WITH_CONVERSATION_CLOSEDocument,
    "\n      mutation ADD_TAG_TO_CONVERSATION($tag_id: bigint!, $conversation_id: bigint!) {\n        payload: insert_conversation_tags_one(\n          object: { tag_id: $tag_id, conversation_id: $conversation_id }\n          on_conflict: { constraint: conversation_tags_conversation_id_tag_id_key, update_columns: [] }\n        ) {\n          tag {\n            name\n          }\n        }\n      }\n    ": types.ADD_TAG_TO_CONVERSATIONDocument,
    "\n      query FILTER_CONTACT_LIST($limit: Int = 20, $offset: Int = 0, $where: contacts_bool_exp = {}) {\n        counts: contacts_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: contacts(order_by: { id: desc }, limit: $limit, offset: $offset, where: $where) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          account_id\n          last_activity_at\n          social_profiles\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    ": types.FILTER_CONTACT_LISTDocument,
    "\n      query GET_CONTACT_COUNT($offset: Int = 0, $where: contacts_bool_exp = {}) {\n        payload: contacts_aggregate(order_by: { id: desc }, offset: $offset, where: $where) {\n          aggregate {\n            count\n          }\n        }\n      }\n    ": types.GET_CONTACT_COUNTDocument,
    "\n      query REPORT_CONVERSATION_COUNTS($date_range: timestamptz_comparison_exp = {}) {\n        total: conversations_aggregate(where: { updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        open: conversations_aggregate(where: { status: { _eq: 0 }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        assigned: conversations_aggregate(where: { agent_id: { _is_null: false }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: conversations_aggregate(where: { agent_id: { _is_null: true }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        closed: conversations_aggregate(where: { status: { _eq: 1 }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    ": types.REPORT_CONVERSATION_COUNTSDocument,
    "\n      query GET_AUTOMATION_RULES {\n        payload: automation_rules(order_by: { id: asc }) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    ": types.GET_AUTOMATION_RULESDocument,
    "\n      mutation CREATE_AUTOMATION_RULES($object: automation_rules_insert_input = {}) {\n        payload: insert_automation_rules_one(object: $object) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    ": types.CREATE_AUTOMATION_RULESDocument,
    "\n      mutation UPDATED_AUTOMATION_RULES($id: bigint!, $_set: automation_rules_set_input = {}) {\n        payload: update_automation_rules_by_pk(pk_columns: { id: $id }, _set: $_set) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    ": types.UPDATED_AUTOMATION_RULESDocument,
    "\n      mutation DELETE_AUTOMATION_RULES($id: bigint!) {\n        payload: delete_automation_rules_by_pk(id: $id) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    ": types.DELETE_AUTOMATION_RULESDocument,
    "\n      mutation UPDATE_USER_STATUS($user_id: bigint!, $availability: Int!) {\n        payload: update_account_users(where: { user_id: { _eq: $user_id } }, _set: { availability: $availability }) {\n          affected_rows\n          returning {\n            user_id\n            availability\n          }\n        }\n      }\n    ": types.UPDATE_USER_STATUSDocument,
    "\n      query GET_USER_STATUS($user_id: bigint!) {\n        payload: account_agents(where: { id: { _eq: $user_id } }) {\n          id\n          availability\n        }\n      }\n    ": types.GET_USER_STATUSDocument,
    "\n      query GET_CONTACT_BY_ID($id: Int!) {\n        payload: contacts_by_pk(id: $id) {\n          id\n          name\n          email\n          gender\n          city\n          profile_twitter\n          profile_instagram\n          preferred_language\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          last_activity_at\n          conversations {\n            id\n            account {\n              name\n            }\n            status\n            incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n              aggregate {\n                count\n              }\n            }\n            outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n              aggregate {\n                count\n              }\n            }\n            conversation_tags {\n              tag {\n                name\n              }\n            }\n            created_at\n            agent {\n              name\n            }\n            inbox {\n              channel_type\n            }\n          }\n          contact_tags {\n            tag {\n              id\n              color\n              name\n            }\n          }\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    ": types.GET_CONTACT_BY_IDDocument,
    "\n      query GET_CONTACT_BY_PHONE_NUMBER($phone_number: String!) {\n        payload: contacts(where: { phone_number: { _eq: $phone_number } }) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          account_id\n          last_activity_at\n          social_profiles\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    ": types.GET_CONTACT_BY_PHONE_NUMBERDocument,
    "\n      query TICKET_CONTACTS($search_contacts: String!) {\n        payload: contacts(\n          where: { _and: [{ _or: [{ name: { _ilike: $search_contacts } }, { email: { _ilike: $search_contacts } }, { phone_number: { _ilike: $search_contacts } }] }] }\n        ) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n        }\n      }\n    ": types.TICKET_CONTACTSDocument,
    "\n      query GET_TICKET_FORM_LIST {\n        payload: ticket_forms {\n          id\n          type\n          description\n          enabled\n          survey_form\n          account_id\n          created_at\n          updated_at\n        }\n      }\n    ": types.GET_TICKET_FORM_LISTDocument,
    "\n      query GET_TICKET_FORM_BY_ID($id: bigint!) {\n        payload: ticket_forms_by_pk(id: $id) {\n          id\n          survey_form\n          type\n          description\n        }\n      }\n    ": types.GET_TICKET_FORM_BY_IDDocument,
    "\n      mutation CREATE_TICKET_FORM($object: ticket_forms_insert_input = {}) {\n        payload: insert_ticket_forms_one(object: $object) {\n          description\n          enabled\n          id\n          survey_form\n          type\n        }\n      }\n    ": types.CREATE_TICKET_FORMDocument,
    "\n      mutation UPDATE_TICKET_FORM_BY_ID($id: bigint!, $survey_form: json = {}) {\n        payload: update_ticket_forms_by_pk(pk_columns: { id: $id }, _set: { survey_form: $survey_form }) {\n          id\n          updated_at\n          survey_form\n          type\n        }\n      }\n    ": types.UPDATE_TICKET_FORM_BY_IDDocument,
    "\n      mutation DELETE_TICKET_FORM($id: bigint!) {\n        payload: delete_ticket_forms_by_pk(id: $id) {\n          id\n          type\n          description\n        }\n      }\n    ": types.DELETE_TICKET_FORMDocument,
    "\n      query GET_TICKET_BY_ID($id: bigint!) {\n        payload: ticket_by_pk(id: $id) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          conversation_id\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n          contact {\n            id\n            name\n            email\n            phone_number\n            preferred_language\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n            social_profiles\n            conversations {\n              id\n              messages {\n                id\n                message\n              }\n            }\n          }\n          created_user {\n            name\n          }\n          ticket_shares {\n            team {\n              id\n              name\n            }\n          }\n        }\n      }\n    ": types.GET_TICKET_BY_IDDocument,
    "\n      mutation LINK_CONVERSATION_ID_TO_TICKET($conversationId: bigint!, $ticketId: bigint!) {\n        payload: update_ticket_by_pk(pk_columns: { id: $ticketId }, _set: { conversation_id: $conversationId }) {\n          conversation_id\n        }\n      }\n    ": types.LINK_CONVERSATION_ID_TO_TICKETDocument,
    "\n      mutation CREATE_TICKET($object: ticket_insert_input = {}) {\n        payload: insert_ticket_one(object: $object) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n          ticket_shares {\n            id\n            team_id\n            ticket_id\n          }\n        }\n      }\n    ": types.CREATE_TICKETDocument,
    "\n      mutation UPDATE_TICKET($ticket_id: Int!, $teams_id: [Int!], $ticket_share: [ticket_share_insert_input!] = {}, $id: bigint!, $_set: ticket_set_input = {}) {\n        delete_ticket_share(where: { ticket_id: { _eq: $ticket_id }, team_id: { _nin: $teams_id } }) {\n          returning {\n            id\n            team_id\n            ticket_id\n          }\n        }\n        insert_ticket_share(on_conflict: { constraint: ticket_share_ticket_id_team_id_key, update_columns: [] }, objects: $ticket_share) {\n          returning {\n            id\n            team_id\n            ticket_id\n          }\n        }\n        updated_ticket: update_ticket_by_pk(pk_columns: { id: $id }, _set: $_set) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    ": types.UPDATE_TICKETDocument,
    "\n      mutation DELETE_TICKET($id: bigint!) {\n        payload: delete_ticket_by_pk(id: $id) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    ": types.DELETE_TICKETDocument,
    "\n      query GET_TICKET_BY_CONTACT_ID($id: bigint!) {\n        payload: ticket(where: { contact_id: { _eq: $id } }) {\n          id\n          description\n          subject\n          source\n          status\n          priority\n          created_at\n          updated_at\n          type\n          form_value\n          assigned_agent\n          agent {\n            name\n          }\n          team {\n            name\n            id\n          }\n        }\n      }\n    ": types.GET_TICKET_BY_CONTACT_IDDocument,
    "\n      query GET_TICKET_MESSAGES_BY_TICKET_ID($ticket_id: Int!, $cursor: Int_comparison_exp = {}) {\n        payload: ticket_messages(where: { ticket_id: { _eq: $ticket_id }, id: $cursor }, limit: 20, order_by: { id: desc }) {\n          id\n          message: content\n          content_attributes\n          message_type\n          internal\n          sender_info\n          status\n          source_id\n          created_at\n          ticket_id\n          attachments {\n            id\n            key\n            file_name\n            file_type\n            extension\n            url\n          }\n        }\n      }\n    ": types.GET_TICKET_MESSAGES_BY_TICKET_IDDocument,
    "\n    subscription GET_TICKET_MESSAGES_SUBSCRIPTION($ticketId: Int!) {\n      payload: ticket_messages(where: { ticket_id: { _eq: $ticketId } }, limit: 1, order_by: { id: desc }) {\n        id\n      }\n    }\n  ": types.GET_TICKET_MESSAGES_SUBSCRIPTIONDocument,
    "\n      query GET_SEARCHED_TICKETS($where: ticket_bool_exp) {\n        payload: ticket(where: $where) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    ": types.GET_SEARCHED_TICKETSDocument,
    "\n      query GET_FILTERED_TICKETS($offset: Int = 0, $where: ticket_bool_exp = {}, $id: order_by) {\n        payload: ticket(order_by: { id: $id }, limit: 10, offset: $offset, where: $where) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    ": types.GET_FILTERED_TICKETSDocument,
    "\n    subscription GET_TICKET_COUNT_SUBSCRIPTION($where: ticket_bool_exp = {}) {\n      payload: ticket_aggregate(where: $where) {\n        aggregate {\n          count\n        }\n      }\n    }\n  ": types.GET_TICKET_COUNT_SUBSCRIPTIONDocument,
    "\n    subscription GET_TICKETS_SUBSCRIPTION($where: ticket_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc, $offset1: Int = 10, $created_at1: order_by = asc) {\n      ticket(where: $where, offset: $offset1, limit: 1, order_by: { messages_aggregate: { max: { created_at: $created_at1 } } }) {\n        id\n      }\n    }\n  ": types.GET_TICKETS_SUBSCRIPTIONDocument,
    "\n      query GET_TICKETS_COUNTS($_and: [ticket_bool_exp!] = {}) {\n        mine: ticket_aggregate(where: { tab_type: { _contains: \"mine\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        team: ticket_aggregate(where: { tab_type: { _contains: \"team\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        watching: ticket_aggregate(where: { tab_type: { _contains: \"watching\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        history: ticket_aggregate(where: { tab_type: { _has_keys_any: [\"history\", \"shared\"] }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: ticket_aggregate(where: { tab_type: { _contains: \"unassigned\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    ": types.GET_TICKETS_COUNTSDocument,
    "\n      mutation CREATE_CONTACT($contact_values: contacts_insert_input = {}) {\n        payload: insert_contacts_one(object: $contact_values) {\n          id\n          name\n          email\n          phone_number\n          gender\n          city\n          preferred_language\n          profile_twitter\n        }\n      }\n    ": types.CREATE_CONTACTDocument,
    "\n      mutation UPDATE_PHONE_NUMBER($id: Int!, $set: String!) {\n        payload: update_contacts_by_pk(pk_columns: { id: $id }, _set: { phone_number: $set }) {\n          id\n          phone_number\n        }\n      }\n    ": types.UPDATE_PHONE_NUMBERDocument,
    "\n      query GET_TWITTER_CHANNEL_PROFILES {\n        payload: channel_twitter_profiles {\n          id\n          screen_name\n        }\n      }\n    ": types.GET_TWITTER_CHANNEL_PROFILESDocument,
    "\n      query USER_PROFILE_INFO($id: bigint!) {\n        payload: users_by_pk(id: $id) {\n          availability\n          email\n          display_name\n          id\n          hr_id\n          name\n          phone_number\n          updated_at\n        }\n      }\n    ": types.USER_PROFILE_INFODocument,
    "\n      query GetAllPublishArticles($limit: Int = 20, $offset: Int = 0) {\n        payload: knowledge_base_articles(limit: $limit, offset: $offset, where: { article_status: { _eq: \"published\" } }) {\n          id\n          name\n          body\n          language\n          article_status\n          category {\n            name\n            id\n          }\n        }\n        total: knowledge_base_articles_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    ": types.GetAllPublishArticlesDocument,
    "\n      query GET_PUBLISHED_ARTICLES_BY_ID($id: bigint = \"\") {\n        payload: knowledge_base_articles_by_pk(id: $id) {\n          id\n          name\n          updated_at\n          body\n          meta_tags\n          meta_description\n          language\n          category {\n            id\n            name\n          }\n        }\n      }\n    ": types.GET_PUBLISHED_ARTICLES_BY_IDDocument,
    "\n      query GET_ALL_PUBLISHED_ARTICLES_BY_CATEGORIES($categories: String!) {\n        payload: knowledge_base_articles(where: { article_status: { _eq: \"published\" }, _and: { category: { name: { _eq: $categories } } } }) {\n          id\n          name\n          article_status\n          body\n          category {\n            id\n            name\n          }\n        }\n      }\n    ": types.GET_ALL_PUBLISHED_ARTICLES_BY_CATEGORIESDocument,
    "\n      mutation UPDATE_USER_PROFILE_BY_ID($id: bigint!, $updated_values: users_set_input = {}) {\n        payload: update_users_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          name\n          display_name\n          email\n          phone_number\n        }\n      }\n    ": types.UPDATE_USER_PROFILE_BY_IDDocument,
    "\n      mutation CREATE_KNOWLEDGE_BASE_CATEGORY($object: knowledge_base_categories_insert_input = {}) {\n        payload: insert_knowledge_base_categories_one(object: $object) {\n          id\n          name\n          language\n          description\n          updated_at\n          is_enabled\n        }\n      }\n    ": types.CREATE_KNOWLEDGE_BASE_CATEGORYDocument,
    "\n      query GET_ALL_KNOWLEDGE_BASE_CATEGORIES {\n        total: knowledge_base_categories_aggregate {\n          aggregate {\n            count\n          }\n        }\n        payload: knowledge_base_categories(order_by: { id: asc }) {\n          id\n          name\n          description\n          language\n          is_enabled\n          created_by {\n            name\n          }\n          updated_at\n          created_at\n        }\n      }\n    ": types.GET_ALL_KNOWLEDGE_BASE_CATEGORIESDocument,
    "\n      query GET_CATEGORIES_BY_ID($id: bigint = \"\") {\n        payload: knowledge_base_categories_by_pk(id: $id) {\n          id\n          name\n          language\n          description\n        }\n      }\n    ": types.GET_CATEGORIES_BY_IDDocument,
    "\n      mutation UPDATE_KNOWLEDGE_BASE_CATEGORIES_BY_ID($id: bigint!, $updated_values: knowledge_base_categories_set_input = {}) {\n        payload: update_knowledge_base_categories_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n        }\n      }\n    ": types.UPDATE_KNOWLEDGE_BASE_CATEGORIES_BY_IDDocument,
    "\n      mutation DELETE_KNOWLEDGE_BASE_CATEGORY_BY_ID($id: bigint!) {\n        payload: delete_knowledge_base_categories_by_pk(id: $id) {\n          id\n        }\n      }\n    ": types.DELETE_KNOWLEDGE_BASE_CATEGORY_BY_IDDocument,
    "\n      query GET_ALL_KNOWLEDGE_BASE_ARTICLES($search_content: String = \"\", $offset: Int = 0) {\n        total: knowledge_base_articles_aggregate(\n          where: { _or: [{ name: { _ilike: $search_content } }, { body: { _ilike: $search_content } }] }\n          offset: $offset\n          order_by: { id: asc }\n        ) {\n          aggregate {\n            count\n          }\n        }\n        payload: knowledge_base_articles(where: { _or: [{ name: { _ilike: $search_content } }, { body: { _ilike: $search_content } }] }, offset: $offset, order_by: { id: asc }) {\n          id\n          name\n          body\n          article_status\n          permissions\n          read_count\n          is_enabled\n          language\n          meta_tags\n          meta_description\n          conversation_trigger\n          category_id\n          created_by {\n            name\n          }\n          created_at\n          updated_at\n          category {\n            name\n          }\n        }\n      }\n    ": types.GET_ALL_KNOWLEDGE_BASE_ARTICLESDocument,
    "\n      mutation CREATE_KNOWLEDGE_BASE_ARTICLE($object: knowledge_base_articles_insert_input = {}) {\n        payload: insert_knowledge_base_articles_one(object: $object) {\n          id\n          name\n          body\n          read_count\n          permissions\n          language\n          is_enabled\n          created_at\n          updated_at\n          article_status\n          conversation_trigger\n          meta_description\n          meta_tags\n          created_by {\n            name\n          }\n        }\n      }\n    ": types.CREATE_KNOWLEDGE_BASE_ARTICLEDocument,
    "\n      query GET_SPECIFIC_ARTICLE_BY_ID($id: bigint!) {\n        payload: knowledge_base_articles_by_pk(id: $id) {\n          id\n          name\n          body\n          article_status\n          permissions\n          read_count\n          is_enabled\n          language\n          meta_tags\n          meta_description\n          conversation_trigger\n          category_id\n          created_by {\n            name\n          }\n          created_at\n          updated_at\n        }\n      }\n    ": types.GET_SPECIFIC_ARTICLE_BY_IDDocument,
    "\n      mutation UPDATE_ARTICLE_BY_ID($id: bigint = \"\", $updated_values: knowledge_base_articles_set_input = {}, $read_count: Int = 1) {\n        payload: update_knowledge_base_articles_by_pk(pk_columns: { id: $id }, _set: $updated_values, _inc: { read_count: $read_count }) {\n          id\n          name\n          read_count\n        }\n      }\n    ": types.UPDATE_ARTICLE_BY_IDDocument,
    "\n      mutation DELETE_ARTICLE_BY_ID($id: bigint = \"\") {\n        payload: delete_knowledge_base_articles_by_pk(id: $id) {\n          id\n        }\n      }\n    ": types.DELETE_ARTICLE_BY_IDDocument,
    "\n      mutation CREATE_TAG($object: tags_insert_input = {}) {\n        payload: insert_tags_one(object: $object) {\n          id\n          name\n          description\n          level\n        }\n      }\n    ": types.CREATE_TAGDocument,
    "\n      query GET_ALL_TAGS($search_items: String!) {\n        total: tags_aggregate {\n          aggregate {\n            count\n          }\n        }\n        payload: tags(where: { _or: [{ name: { _ilike: $search_items } }, { description: { _ilike: $search_items } }] }, order_by: { id: asc }) {\n          id\n          name\n          description\n          is_enabled\n          level\n          created_at\n          updated_at\n          smart_tags\n          account_id\n          created_by {\n            id\n            name\n          }\n        }\n      }\n    ": types.GET_ALL_TAGSDocument,
    "\n      query GET_A_TAG_BY_ID($id: bigint = \"\") {\n        payload: tags_by_pk(id: $id) {\n          id\n          name\n          description\n          level\n          smart_tags\n        }\n      }\n    ": types.GET_A_TAG_BY_IDDocument,
    "\n      mutation UPDATED_TAGS($updated_values: tags_set_input = {}, $id: bigint = \"\") {\n        payload: update_tags_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n      }\n    ": types.UPDATED_TAGSDocument,
    "\n      mutation DELETE_TAG_BY_ID($id: bigint!) {\n        payload: delete_tags_by_pk(id: $id) {\n          id\n          name\n          description\n          level\n          is_enabled\n          created_at\n          updated_at\n        }\n      }\n    ": types.DELETE_TAG_BY_IDDocument,
    "\n      mutation UPDATED_CONTACT_REASON_BY_ID($id: bigint = \"\", $categories: jsonb = \"\") {\n        payload: update_workflows_contact_reason_by_pk(pk_columns: { id: $id }, _set: { categories: $categories }) {\n          id\n          updated_at\n          contact_reason\n          categories\n        }\n      }\n    ": types.UPDATED_CONTACT_REASON_BY_IDDocument,
    "\n      query GET_ALL_CONTACT_REASONS {\n        payload: workflows_contact_reason {\n          categories\n          contact_reason\n          created_at\n          id\n          updated_at\n        }\n      }\n    ": types.GET_ALL_CONTACT_REASONSDocument,
    "\n      mutation UPDATE_LAST_ACTIVE_AT($user_id: bigint!) {\n        payload: update_account_users(where: { user_id: { _eq: $user_id } }, _set: { last_active_at: \"now()\" }) {\n          returning {\n            user_id\n            last_active_at\n          }\n        }\n      }\n    ": types.UPDATE_LAST_ACTIVE_ATDocument,
    "\n      mutation ADD_AGENT($object: account_users_insert_input!) {\n        payload: insert_account_users_one(object: $object, on_conflict: { constraint: account_users_account_id_user_id_key, update_columns: [] }) {\n          id\n          user_id\n        }\n      }\n    ": types.ADD_AGENTDocument,
    "\n      query GET_CONVERSATION_CSAT($csat_id: String!) {\n        payload: conversations(where: { csat_id: { _eq: $csat_id } }) {\n          id\n          contact_id\n          csat_sent\n          csat_sent_at\n          csat_language\n          csat_feedback {\n            satisfaction_point\n            open_question_ans\n          }\n        }\n      }\n    ": types.GET_CONVERSATION_CSATDocument,
    "\n      query GET_TICKET_CSAT($csat_id: String!) {\n        payload: ticket(where: { csat_id: { _eq: $csat_id } }) {\n          id\n          contact_id\n          csat_sent\n          csat_sent_at\n          csat_language\n          csat_feedback {\n            satisfaction_point\n            open_question_ans\n          }\n        }\n      }\n    ": types.GET_TICKET_CSATDocument,
    "\n      mutation ADD_CSAT_FEEDBACK($object: csat_feedback_insert_input!) {\n        payload: insert_csat_feedback_one(object: $object) {\n          contact_id\n          conversation_id\n          ticket_id\n          satisfaction_point\n          open_question_ans\n        }\n      }\n    ": types.ADD_CSAT_FEEDBACKDocument,
    "\n      query GET_CSAT_SCORE($where: csat_feedback_bool_exp = {}) {\n        feedback: csat_feedback(where: $where) {\n          satisfaction_point\n          open_question_ans\n          conversation_id\n          ticket_id\n        }\n        aggregations: csat_feedback_aggregate(where: $where) {\n          aggregate {\n            count\n            sum {\n              satisfaction_point\n            }\n          }\n        }\n      }\n    ": types.GET_CSAT_SCOREDocument,
    "\n      query GET_INSTAGRAM_PAGES {\n        payload: channel_instagram {\n          page_id\n        }\n      }\n    ": types.GET_INSTAGRAM_PAGESDocument,
    "\n      mutation UPDATE_INSTAGRAM_INBOX_BY_ID($inbox_id: Int!, $inbox_update_values: inboxes_set_input = {}) {\n        payload: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n      }\n    ": types.UPDATE_INSTAGRAM_INBOX_BY_IDDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_INBOXES($filter: inboxes_bool_exp, $offset: Int = 0, $limit: Int = 20) {\n        total: inboxes_aggregate(where: $filter) {\n          aggregate {\n            count\n          }\n        }\n        payload: inboxes(where: $filter, offset: $offset, limit: $limit, order_by: { id: asc }) {\n          id\n          name\n          channel_type\n          channel_id\n          channel\n          description\n          is_enabled\n          created_at\n          updated_at\n          reply_channel_id\n          total_conversations: conversations_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_INBOXES($filter: inboxes_bool_exp, $offset: Int = 0, $limit: Int = 20) {\n        total: inboxes_aggregate(where: $filter) {\n          aggregate {\n            count\n          }\n        }\n        payload: inboxes(where: $filter, offset: $offset, limit: $limit, order_by: { id: asc }) {\n          id\n          name\n          channel_type\n          channel_id\n          channel\n          description\n          is_enabled\n          created_at\n          updated_at\n          reply_channel_id\n          total_conversations: conversations_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_INBOXES_BY_ID($id: Int!) {\n        payload: inboxes_by_pk(id: $id) {\n          id\n          name\n          reply_channel_id\n          channel_type\n          channel\n        }\n      }\n    "): (typeof documents)["\n      query GET_INBOXES_BY_ID($id: Int!) {\n        payload: inboxes_by_pk(id: $id) {\n          id\n          name\n          reply_channel_id\n          channel_type\n          channel\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_INBOXES_BY_ID($id: Int!, $updated_values: inboxes_set_input = {}) {\n        payload: update_inboxes_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          name\n          is_enabled\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_INBOXES_BY_ID($id: Int!, $updated_values: inboxes_set_input = {}) {\n        payload: update_inboxes_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          name\n          is_enabled\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_EMAIL_INBOX_BY_ID($inbox_id: Int!, $channel_id: Int!, $inbox_update_values: inboxes_set_input = {}, $channel_update_values: channel_email_set_input = {}) {\n        updated_inbox: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n        updated_channel: update_channel_email_by_pk(pk_columns: { id: $channel_id }, _set: $channel_update_values) {\n          id\n          imap_enabled\n          imap_username\n          imap_host_address\n          imap_port\n          smtp_enabled\n          smtp_username\n          smtp_host_address\n          smtp_port\n          smtp_requires_ssl\n          updated_at\n          smtp_email\n          imap_password\n          smtp_password\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_EMAIL_INBOX_BY_ID($inbox_id: Int!, $channel_id: Int!, $inbox_update_values: inboxes_set_input = {}, $channel_update_values: channel_email_set_input = {}) {\n        updated_inbox: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n        updated_channel: update_channel_email_by_pk(pk_columns: { id: $channel_id }, _set: $channel_update_values) {\n          id\n          imap_enabled\n          imap_username\n          imap_host_address\n          imap_port\n          smtp_enabled\n          smtp_username\n          smtp_host_address\n          smtp_port\n          smtp_requires_ssl\n          updated_at\n          smtp_email\n          imap_password\n          smtp_password\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_WHATSAPP_INBOX_BY_ID(\n        $inbox_id: Int!\n        $channel_id: bigint!\n        $inbox_update_values: inboxes_set_input = {}\n        $channel_update_values: channel_whatsapp_set_input = {}\n      ) {\n        updated_inbox: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n        updated_channel: update_channel_whatsapp_by_pk(pk_columns: { id: $channel_id }, _set: $channel_update_values) {\n          id\n          phone_number\n          phone_number_id\n          business_account_id\n          access_token\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_WHATSAPP_INBOX_BY_ID(\n        $inbox_id: Int!\n        $channel_id: bigint!\n        $inbox_update_values: inboxes_set_input = {}\n        $channel_update_values: channel_whatsapp_set_input = {}\n      ) {\n        updated_inbox: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n        updated_channel: update_channel_whatsapp_by_pk(pk_columns: { id: $channel_id }, _set: $channel_update_values) {\n          id\n          phone_number\n          phone_number_id\n          business_account_id\n          access_token\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_INBOX_BY_ID($inboxId: Int!) {\n        payload: delete_inboxes_by_pk(id: $inboxId) {\n          id\n          name\n          channel_type\n          channel_id\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_INBOX_BY_ID($inboxId: Int!) {\n        payload: delete_inboxes_by_pk(id: $inboxId) {\n          id\n          name\n          channel_type\n          channel_id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONVERSATION_LIST($where: conversations_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc) {\n        payload: conversations(where: $where, offset: $offset, limit: 10, order_by: { messages_aggregate: { max: { created_at: $created_at } } }) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n            channel\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(limit: 1, order_by: { created_at: desc }, where: { message_type: { _neq: 2 } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            conversation {\n              inbox {\n                channel\n              }\n            }\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONVERSATION_LIST($where: conversations_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc) {\n        payload: conversations(where: $where, offset: $offset, limit: 10, order_by: { messages_aggregate: { max: { created_at: $created_at } } }) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n            channel\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(limit: 1, order_by: { created_at: desc }, where: { message_type: { _neq: 2 } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            conversation {\n              inbox {\n                channel\n              }\n            }\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONVERSATION_COUNTS($_and: [conversations_bool_exp!] = {}) {\n        mine: conversations_aggregate(where: { tab_type: { _contains: \"mine\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        pending: conversations_aggregate(where: { tab_type: { _contains: \"pending\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        watching: conversations_aggregate(where: { tab_type: { _contains: \"watching\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        history: conversations_aggregate(where: { tab_type: { _contains: \"history\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: conversations_aggregate(where: { tab_type: { _contains: \"unassigned\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONVERSATION_COUNTS($_and: [conversations_bool_exp!] = {}) {\n        mine: conversations_aggregate(where: { tab_type: { _contains: \"mine\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        pending: conversations_aggregate(where: { tab_type: { _contains: \"pending\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        watching: conversations_aggregate(where: { tab_type: { _contains: \"watching\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        history: conversations_aggregate(where: { tab_type: { _contains: \"history\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: conversations_aggregate(where: { tab_type: { _contains: \"unassigned\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n    subscription GET_SUBSCRIPTION_CONVERSATION_COUNT($where: conversations_bool_exp = {}) {\n      payload: conversations_aggregate(where: $where) {\n        aggregate {\n          count\n        }\n      }\n    }\n  "): (typeof documents)["\n    subscription GET_SUBSCRIPTION_CONVERSATION_COUNT($where: conversations_bool_exp = {}) {\n      payload: conversations_aggregate(where: $where) {\n        aggregate {\n          count\n        }\n      }\n    }\n  "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n    subscription GET_CONVERSATIONS_SUBSCRIPTION($where: conversations_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc) {\n      payload: conversations(where: $where, offset: $offset, limit: 1, order_by: { messages_aggregate: { max: { created_at: $created_at } } }) {\n        id\n      }\n    }\n  "): (typeof documents)["\n    subscription GET_CONVERSATIONS_SUBSCRIPTION($where: conversations_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc) {\n      payload: conversations(where: $where, offset: $offset, limit: 1, order_by: { messages_aggregate: { max: { created_at: $created_at } } }) {\n        id\n      }\n    }\n  "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONVERSATION_BY_ID($conversationId: bigint!) {\n        payload: conversations_by_pk(id: $conversationId) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          created_at\n          closing_contact_reason_value\n          additional_attributes\n          contact {\n            id\n            name\n            email\n            phone_number\n            preferred_language\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          agent {\n            id\n            name\n            display_name\n            email\n          }\n          inbox {\n            name\n            channel\n            reply_channel {\n              id\n              screen_name\n            }\n            team_inboxes {\n              team {\n                id\n                name\n              }\n            }\n          }\n          conversation_tags {\n            tag {\n              id\n              name\n              color\n            }\n          }\n          assigned_team_member {\n            team {\n              id\n              name\n            }\n            user {\n              id\n              name\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONVERSATION_BY_ID($conversationId: bigint!) {\n        payload: conversations_by_pk(id: $conversationId) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          created_at\n          closing_contact_reason_value\n          additional_attributes\n          contact {\n            id\n            name\n            email\n            phone_number\n            preferred_language\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          agent {\n            id\n            name\n            display_name\n            email\n          }\n          inbox {\n            name\n            channel\n            reply_channel {\n              id\n              screen_name\n            }\n            team_inboxes {\n              team {\n                id\n                name\n              }\n            }\n          }\n          conversation_tags {\n            tag {\n              id\n              name\n              color\n            }\n          }\n          assigned_team_member {\n            team {\n              id\n              name\n            }\n            user {\n              id\n              name\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_FILTERED_CONVERSATION($search_content: String = \"%%\", $where: conversations_bool_exp) {\n        payload: conversations(limit: 10, order_by: { messages_aggregate: { max: { created_at: desc } } }, offset: 0, where: $where) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(order_by: { id: desc }, where: { message: { _ilike: $search_content }, message_type: { _in: [0, 1] } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            conversation {\n              inbox {\n                channel\n              }\n            }\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_FILTERED_CONVERSATION($search_content: String = \"%%\", $where: conversations_bool_exp) {\n        payload: conversations(limit: 10, order_by: { messages_aggregate: { max: { created_at: desc } } }, offset: 0, where: $where) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(order_by: { id: desc }, where: { message: { _ilike: $search_content }, message_type: { _in: [0, 1] } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            conversation {\n              inbox {\n                channel\n              }\n            }\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONVERSATION_BY_CONTACT_ID($contact_id: Int!) {\n        payload: conversations(where: { contact_id: { _eq: $contact_id }, inbox_id: { _is_null: false } }) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n            channel\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(order_by: { id: desc }, limit: 1, where: { message_type: { _neq: 2 } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n          account {\n            name\n          }\n          conversation_tags {\n            tag {\n              id\n              name\n              color\n            }\n          }\n          agent {\n            name\n          }\n          assigned_team_member {\n            user {\n              name\n              id\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONVERSATION_BY_CONTACT_ID($contact_id: Int!) {\n        payload: conversations(where: { contact_id: { _eq: $contact_id }, inbox_id: { _is_null: false } }) {\n          id\n          inbox_id\n          contact_id\n          conversation_type: type\n          status\n          snoozed_until\n          contact {\n            id\n            name\n            email\n            phone_number\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n          }\n          created_at\n          inbox {\n            name\n            channel_type\n            channel\n          }\n          unread_messages: messages_aggregate(where: { status: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n            aggregate {\n              count\n            }\n          }\n          outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n            aggregate {\n              count\n            }\n          }\n          messages(order_by: { id: desc }, limit: 1, where: { message_type: { _neq: 2 } }) {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n          account {\n            name\n          }\n          conversation_tags {\n            tag {\n              id\n              name\n              color\n            }\n          }\n          agent {\n            name\n          }\n          assigned_team_member {\n            user {\n              name\n              id\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CUSTOM_FILTERS($type: Int!) {\n        payload: custom_filters(where: { filter_type: { _eq: $type } }) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "): (typeof documents)["\n      query GET_CUSTOM_FILTERS($type: Int!) {\n        payload: custom_filters(where: { filter_type: { _eq: $type } }) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CUSTOM_FILTER_BY_ID($id: bigint!) {\n        payload: custom_filters_by_pk(id: $id) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "): (typeof documents)["\n      query GET_CUSTOM_FILTER_BY_ID($id: bigint!) {\n        payload: custom_filters_by_pk(id: $id) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_CUSTOM_FILTER($object: custom_filters_insert_input = {}) {\n        payload: insert_custom_filters_one(object: $object) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_CUSTOM_FILTER($object: custom_filters_insert_input = {}) {\n        payload: insert_custom_filters_one(object: $object) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_CUSTOM_FILTER_BY_ID($id: bigint!, $set: custom_filters_set_input = {}) {\n        payload: update_custom_filters_by_pk(pk_columns: { id: $id }, _set: $set) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_CUSTOM_FILTER_BY_ID($id: bigint!, $set: custom_filters_set_input = {}) {\n        payload: update_custom_filters_by_pk(pk_columns: { id: $id }, _set: $set) {\n          id\n          name\n          query\n          filter_type\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_CUSTOM_FILTER_BY_ID($id: bigint = \"\") {\n        payload: delete_custom_filters_by_pk(id: $id) {\n          id\n          name\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_CUSTOM_FILTER_BY_ID($id: bigint = \"\") {\n        payload: delete_custom_filters_by_pk(id: $id) {\n          id\n          name\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_MESSAGES($conversationId: bigint!, $offset: Int) {\n        payload: messages(where: { conversation_id: { _eq: $conversationId } }, limit: 10, order_by: { created_at: desc }, offset: $offset) {\n          id\n          message\n          message_type\n          conversation_id\n          created_at\n          internal\n          content_attributes\n          approved_at\n          source_id\n          sender_id\n          sender_info\n          attachments {\n            id\n            key\n            file_name\n            file_type\n            extension\n            url\n          }\n          reply_of_message {\n            id\n            message\n          }\n          conversation {\n            type\n            inbox {\n              name\n              channel_type\n              channel\n            }\n            contact {\n              id\n              name\n              email\n              phone_number\n              profile_image: source(path: \"profile_image\")\n              source\n              created_at\n              updated_at\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_MESSAGES($conversationId: bigint!, $offset: Int) {\n        payload: messages(where: { conversation_id: { _eq: $conversationId } }, limit: 10, order_by: { created_at: desc }, offset: $offset) {\n          id\n          message\n          message_type\n          conversation_id\n          created_at\n          internal\n          content_attributes\n          approved_at\n          source_id\n          sender_id\n          sender_info\n          attachments {\n            id\n            key\n            file_name\n            file_type\n            extension\n            url\n          }\n          reply_of_message {\n            id\n            message\n          }\n          conversation {\n            type\n            inbox {\n              name\n              channel_type\n              channel\n            }\n            contact {\n              id\n              name\n              email\n              phone_number\n              profile_image: source(path: \"profile_image\")\n              source\n              created_at\n              updated_at\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n    subscription GET_MESSAGES_SUBSCRIPTION($conversationId: bigint!) {\n      payload: messages(where: { conversation_id: { _eq: $conversationId } }, limit: 1, order_by: { created_at: desc }) {\n        id\n      }\n    }\n  "): (typeof documents)["\n    subscription GET_MESSAGES_SUBSCRIPTION($conversationId: bigint!) {\n      payload: messages(where: { conversation_id: { _eq: $conversationId } }, limit: 1, order_by: { created_at: desc }) {\n        id\n      }\n    }\n  "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n    subscription GET_MESSAGES_COUNT_BY_CONVERSATION_ID($conversationId: bigint = 10) {\n      payload: messages_aggregate(where: { conversation_id: { _eq: $conversationId } }) {\n        aggregate {\n          count\n        }\n      }\n    }\n  "): (typeof documents)["\n    subscription GET_MESSAGES_COUNT_BY_CONVERSATION_ID($conversationId: bigint = 10) {\n      payload: messages_aggregate(where: { conversation_id: { _eq: $conversationId } }) {\n        aggregate {\n          count\n        }\n      }\n    }\n  "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation READ_MESSAGES($conversation_id: bigint!) {\n        payload: update_messages(where: { conversation_id: { _eq: $conversation_id }, status: { _eq: 1 } }, _set: { status: 0 }) {\n          returning {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation READ_MESSAGES($conversation_id: bigint!) {\n        payload: update_messages(where: { conversation_id: { _eq: $conversation_id }, status: { _eq: 1 } }, _set: { status: 0 }) {\n          returning {\n            id\n            message\n            message_type\n            conversation_id\n            created_at\n            internal\n            content_attributes\n            approved_at\n            source_id\n            sender_id\n            sender_info\n            attachments {\n              id\n              key\n              file_name\n              file_type\n              extension\n              url\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_AGENT_LIST($where: account_agents_bool_exp = {}, $offset: Int = 0, $limit: Int = 20) {\n        total: account_agents_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: account_agents(limit: $limit, offset: $offset, order_by: { id: desc }, where: $where) {\n          id\n          name\n          phone_number\n          email\n          avatar_url\n          role\n          is_enabled\n          verified\n          team_list: team_members {\n            team {\n              id\n              name\n            }\n            user_id\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_AGENT_LIST($where: account_agents_bool_exp = {}, $offset: Int = 0, $limit: Int = 20) {\n        total: account_agents_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: account_agents(limit: $limit, offset: $offset, order_by: { id: desc }, where: $where) {\n          id\n          name\n          phone_number\n          email\n          avatar_url\n          role\n          is_enabled\n          verified\n          team_list: team_members {\n            team {\n              id\n              name\n            }\n            user_id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_AGENT_BY_ID($user_id: bigint!) {\n        payload: account_agents(where: { id: { _eq: $user_id } }) {\n          id\n          name\n          role\n          email\n          phone_number\n          verified\n          invited_by {\n            id\n            name\n          }\n          team_members {\n            team {\n              id\n              name\n              is_enabled\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_AGENT_BY_ID($user_id: bigint!) {\n        payload: account_agents(where: { id: { _eq: $user_id } }) {\n          id\n          name\n          role\n          email\n          phone_number\n          verified\n          invited_by {\n            id\n            name\n          }\n          team_members {\n            team {\n              id\n              name\n              is_enabled\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_AGENT($agent_id: bigint!, $set_account_users: account_users_set_input = {}, $set_user: users_set_input = {}) {\n        account_users: update_account_users(where: { user_id: { _eq: $agent_id } }, _set: $set_account_users) {\n          returning {\n            id\n          }\n        }\n        user: update_users_by_pk(pk_columns: { id: $agent_id }, _set: $set_user) {\n          id\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_AGENT($agent_id: bigint!, $set_account_users: account_users_set_input = {}, $set_user: users_set_input = {}) {\n        account_users: update_account_users(where: { user_id: { _eq: $agent_id } }, _set: $set_account_users) {\n          returning {\n            id\n          }\n        }\n        user: update_users_by_pk(pk_columns: { id: $agent_id }, _set: $set_user) {\n          id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_AGENT_STATUS($agent_id: bigint!, $is_enabled: Boolean!) {\n        payload: update_account_users(where: { user_id: { _eq: $agent_id } }, _set: { is_enabled: $is_enabled }) {\n          returning {\n            user_id\n            is_enabled\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_AGENT_STATUS($agent_id: bigint!, $is_enabled: Boolean!) {\n        payload: update_account_users(where: { user_id: { _eq: $agent_id } }, _set: { is_enabled: $is_enabled }) {\n          returning {\n            user_id\n            is_enabled\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_AGENT_BY_ID($agent_id: bigint!) {\n        payload: delete_account_users(where: { user_id: { _eq: $agent_id } }) {\n          returning {\n            id\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_AGENT_BY_ID($agent_id: bigint!) {\n        payload: delete_account_users(where: { user_id: { _eq: $agent_id } }) {\n          returning {\n            id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TEAMS($filter: teams_bool_exp, $offset: Int = 0, $limit: Int = 20) {\n        payload: teams(where: $filter, order_by: { id: asc }, limit: $limit, offset: $offset) {\n          id\n          name\n          type\n          description\n          is_enabled\n          team_members {\n            id\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n        total: teams_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TEAMS($filter: teams_bool_exp, $offset: Int = 0, $limit: Int = 20) {\n        payload: teams(where: $filter, order_by: { id: asc }, limit: $limit, offset: $offset) {\n          id\n          name\n          type\n          description\n          is_enabled\n          team_members {\n            id\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n        total: teams_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TEAM_BY_MEMBER_ID($agent_id: bigint!, $conversation_id: bigint!) {\n        payload: teams(where: { team_members: { user_id: { _eq: $agent_id } }, team_inboxes: { inbox: { conversations: { id: { _eq: $conversation_id } } } } }) {\n          id\n          name\n          is_enabled\n          allow_auto_assign\n        }\n      }\n    "): (typeof documents)["\n      query GET_TEAM_BY_MEMBER_ID($agent_id: bigint!, $conversation_id: bigint!) {\n        payload: teams(where: { team_members: { user_id: { _eq: $agent_id } }, team_inboxes: { inbox: { conversations: { id: { _eq: $conversation_id } } } } }) {\n          id\n          name\n          is_enabled\n          allow_auto_assign\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TEAM_BY_USER_ID($user_id: bigint!) {\n        payload: teams(where: { team_members: { user_id: { _eq: $user_id } } }) {\n          id\n          name\n        }\n      }\n    "): (typeof documents)["\n      query GET_TEAM_BY_USER_ID($user_id: bigint!) {\n        payload: teams(where: { team_members: { user_id: { _eq: $user_id } } }) {\n          id\n          name\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_TEAM($object: teams_insert_input!) {\n        payload: insert_teams_one(object: $object) {\n          id\n          name\n          description\n          is_enabled\n          type\n          team_members {\n            id\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_TEAM($object: teams_insert_input!) {\n        payload: insert_teams_one(object: $object) {\n          id\n          name\n          description\n          is_enabled\n          type\n          team_members {\n            id\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_TEAM($team_id: bigint!) {\n        payload: delete_teams_by_pk(id: $team_id) {\n          id\n          name\n          type\n          description\n          is_enabled\n          team_members {\n            id\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_TEAM($team_id: bigint!) {\n        payload: delete_teams_by_pk(id: $team_id) {\n          id\n          name\n          type\n          description\n          is_enabled\n          team_members {\n            id\n            user {\n              id\n              name\n            }\n          }\n          team_inboxes {\n            id\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_TEAM_BY_ID(\n        $team_id: bigint!\n        $set: teams_set_input!\n        $member_ids: [bigint!]\n        $inserted_team_members: [team_members_insert_input!]!\n        $inbox_ids: [bigint!]\n        $inserted_team_inboxes: [team_inboxes_insert_input!]!\n      ) {\n        deleted_team_members: delete_team_members(where: { team_id: { _eq: $team_id }, user_id: { _nin: $member_ids } }) {\n          returning {\n            team_id\n            user_id\n          }\n        }\n        inserted_team_members: insert_team_members(\n          objects: $inserted_team_members\n          on_conflict: { constraint: team_members_team_id_user_id_key, update_columns: [approval_enabled, auto_assign_enabled, max_conversation_queue] }\n        ) {\n          returning {\n            team_id\n            user_id\n          }\n        }\n        deleted_team_inboxes: delete_team_inboxes(where: { team_id: { _eq: $team_id }, inbox_id: { _nin: $inbox_ids } }) {\n          returning {\n            team_id\n            inbox_id\n          }\n        }\n        inserted_team_inboxes: insert_team_inboxes(objects: $inserted_team_inboxes, on_conflict: { constraint: team_inboxes_team_id_inbox_id_key, update_columns: [] }) {\n          returning {\n            team_id\n            inbox_id\n          }\n        }\n        updated_team: update_teams_by_pk(pk_columns: { id: $team_id }, _set: $set) {\n          id\n          name\n          type\n          is_enabled\n          team_members {\n            team_id\n            user_id\n            approval_enabled\n            auto_assign_enabled\n            max_conversation_queue\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_TEAM_BY_ID(\n        $team_id: bigint!\n        $set: teams_set_input!\n        $member_ids: [bigint!]\n        $inserted_team_members: [team_members_insert_input!]!\n        $inbox_ids: [bigint!]\n        $inserted_team_inboxes: [team_inboxes_insert_input!]!\n      ) {\n        deleted_team_members: delete_team_members(where: { team_id: { _eq: $team_id }, user_id: { _nin: $member_ids } }) {\n          returning {\n            team_id\n            user_id\n          }\n        }\n        inserted_team_members: insert_team_members(\n          objects: $inserted_team_members\n          on_conflict: { constraint: team_members_team_id_user_id_key, update_columns: [approval_enabled, auto_assign_enabled, max_conversation_queue] }\n        ) {\n          returning {\n            team_id\n            user_id\n          }\n        }\n        deleted_team_inboxes: delete_team_inboxes(where: { team_id: { _eq: $team_id }, inbox_id: { _nin: $inbox_ids } }) {\n          returning {\n            team_id\n            inbox_id\n          }\n        }\n        inserted_team_inboxes: insert_team_inboxes(objects: $inserted_team_inboxes, on_conflict: { constraint: team_inboxes_team_id_inbox_id_key, update_columns: [] }) {\n          returning {\n            team_id\n            inbox_id\n          }\n        }\n        updated_team: update_teams_by_pk(pk_columns: { id: $team_id }, _set: $set) {\n          id\n          name\n          type\n          is_enabled\n          team_members {\n            team_id\n            user_id\n            approval_enabled\n            auto_assign_enabled\n            max_conversation_queue\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TEAM_BY_ID($team_id: bigint!) {\n        payload: teams_by_pk(id: $team_id) {\n          id\n          name\n          type\n          description\n          is_enabled\n          allow_auto_assign\n          team_members {\n            user {\n              id\n              name\n            }\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n          }\n          team_inboxes {\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TEAM_BY_ID($team_id: bigint!) {\n        payload: teams_by_pk(id: $team_id) {\n          id\n          name\n          type\n          description\n          is_enabled\n          allow_auto_assign\n          team_members {\n            user {\n              id\n              name\n            }\n            auto_assign_enabled\n            approval_enabled\n            max_conversation_queue\n          }\n          team_inboxes {\n            inbox {\n              id\n              name\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation ADD_TEAM_MEMBERS($objects: [team_members_insert_input!] = {}) {\n        payload: insert_team_members(objects: $objects, on_conflict: { constraint: team_members_team_id_user_id_key, update_columns: [] }) {\n          returning {\n            id\n            team_id\n            user_id\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation ADD_TEAM_MEMBERS($objects: [team_members_insert_input!] = {}) {\n        payload: insert_team_members(objects: $objects, on_conflict: { constraint: team_members_team_id_user_id_key, update_columns: [] }) {\n          returning {\n            id\n            team_id\n            user_id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_TEAM_MEMBER($members: [bigint!]) {\n        payload: delete_team_members(where: { user_id: { _in: $members } }) {\n          affected_rows\n          returning {\n            id\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_TEAM_MEMBER($members: [bigint!]) {\n        payload: delete_team_members(where: { user_id: { _in: $members } }) {\n          affected_rows\n          returning {\n            id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TEAM_MEMBERS_BY_TEAM_ID($team_id: bigint!, $is_enabled: account_users_bool_exp, $mine_id: bigint_comparison_exp) {\n        payload: team_members(where: { team_id: { _eq: $team_id }, user: { account_users: $is_enabled, id: $mine_id } }) {\n          agent: user {\n            id\n            name\n            display_name\n            email\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TEAM_MEMBERS_BY_TEAM_ID($team_id: bigint!, $is_enabled: account_users_bool_exp, $mine_id: bigint_comparison_exp) {\n        payload: team_members(where: { team_id: { _eq: $team_id }, user: { account_users: $is_enabled, id: $mine_id } }) {\n          agent: user {\n            id\n            name\n            display_name\n            email\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TEAM_MEMBERS_BY_INBOX_ID($inbox_id: bigint!) {\n        payload: teams(where: { is_enabled: { _eq: true }, team_inboxes: { inbox_id: { _eq: $inbox_id } } }) {\n          id\n          name\n          team_members(where: { agent: { is_enabled: { _eq: true } } }) {\n            team_id\n            user_id\n            user {\n              name\n              account_users {\n                availability\n              }\n            }\n            max_conversation_queue\n            total_conversations: conversations_aggregate(where: { inbox_id: { _eq: $inbox_id } }) {\n              aggregate {\n                count\n              }\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TEAM_MEMBERS_BY_INBOX_ID($inbox_id: bigint!) {\n        payload: teams(where: { is_enabled: { _eq: true }, team_inboxes: { inbox_id: { _eq: $inbox_id } } }) {\n          id\n          name\n          team_members(where: { agent: { is_enabled: { _eq: true } } }) {\n            team_id\n            user_id\n            user {\n              name\n              account_users {\n                availability\n              }\n            }\n            max_conversation_queue\n            total_conversations: conversations_aggregate(where: { inbox_id: { _eq: $inbox_id } }) {\n              aggregate {\n                count\n              }\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation ASSIGN_TEAM_TO_INBOX($objects: [team_inboxes_insert_input!] = {}) {\n        payload: insert_team_inboxes(objects: $objects, on_conflict: { constraint: team_inboxes_team_id_inbox_id_key, update_columns: [] }) {\n          returning {\n            id\n            team_id\n            inbox_id\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation ASSIGN_TEAM_TO_INBOX($objects: [team_inboxes_insert_input!] = {}) {\n        payload: insert_team_inboxes(objects: $objects, on_conflict: { constraint: team_inboxes_team_id_inbox_id_key, update_columns: [] }) {\n          returning {\n            id\n            team_id\n            inbox_id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation ASSIGN_AGENT_TO_CONVERSATION($conversation_id: bigint!, $agent_id: bigint!, $team_id: bigint!) {\n        payload: update_conversations_by_pk(pk_columns: { id: $conversation_id }, _set: { agent_id: $agent_id, assigned_team_id: $team_id }) {\n          id\n          assigned_team_member {\n            team {\n              id\n              name\n            }\n            user {\n              id\n              name\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation ASSIGN_AGENT_TO_CONVERSATION($conversation_id: bigint!, $agent_id: bigint!, $team_id: bigint!) {\n        payload: update_conversations_by_pk(pk_columns: { id: $conversation_id }, _set: { agent_id: $agent_id, assigned_team_id: $team_id }) {\n          id\n          assigned_team_member {\n            team {\n              id\n              name\n            }\n            user {\n              id\n              name\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_ALL_CANNED_RESPONSES($search_content: String = \"\", $offset: Int = 0, $limit: Int = 20) {\n        total: canned_responses_aggregate(where: { _or: [{ short_code: { _ilike: $search_content } }, { content: { _ilike: $search_content } }] }) {\n          aggregate {\n            count\n          }\n        }\n        payload: canned_responses(where: { _or: [{ short_code: { _ilike: $search_content } }, { content: { _ilike: $search_content } }] }, offset: $offset, limit: $limit) {\n          id\n          short_code\n          content\n          content_html\n          use_count\n          is_enabled\n          category {\n            id\n            name\n          }\n          created_by {\n            name\n            id\n          }\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      query GET_ALL_CANNED_RESPONSES($search_content: String = \"\", $offset: Int = 0, $limit: Int = 20) {\n        total: canned_responses_aggregate(where: { _or: [{ short_code: { _ilike: $search_content } }, { content: { _ilike: $search_content } }] }) {\n          aggregate {\n            count\n          }\n        }\n        payload: canned_responses(where: { _or: [{ short_code: { _ilike: $search_content } }, { content: { _ilike: $search_content } }] }, offset: $offset, limit: $limit) {\n          id\n          short_code\n          content\n          content_html\n          use_count\n          is_enabled\n          category {\n            id\n            name\n          }\n          created_by {\n            name\n            id\n          }\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_CANNED_RESPONSES_BY_ID($id: Int!) {\n        payload: delete_canned_responses_by_pk(id: $id) {\n          id\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_CANNED_RESPONSES_BY_ID($id: Int!) {\n        payload: delete_canned_responses_by_pk(id: $id) {\n          id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_CANNED_RESPONSES($object: canned_responses_insert_input = {}) {\n        payload: insert_canned_responses_one(object: $object) {\n          id\n          short_code\n          content\n          use_count\n          is_enabled\n          category {\n            id\n            name\n          }\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_CANNED_RESPONSES($object: canned_responses_insert_input = {}) {\n        payload: insert_canned_responses_one(object: $object) {\n          id\n          short_code\n          content\n          use_count\n          is_enabled\n          category {\n            id\n            name\n          }\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATED_CANNED_RESPONSES_BY_ID($id: Int!, $updated_values: canned_responses_set_input = {}) {\n        payload: update_canned_responses_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          short_code\n          content\n          content_html\n          is_enabled\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATED_CANNED_RESPONSES_BY_ID($id: Int!, $updated_values: canned_responses_set_input = {}) {\n        payload: update_canned_responses_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          short_code\n          content\n          content_html\n          is_enabled\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_All_CANNED_RESPONSE_CATEGORIES(\n        $limit: Int = 20\n        $offset: Int = 0\n        $order_by: [canned_responses_category_order_by!] = {}\n        $where: canned_responses_category_bool_exp = {}\n      ) {\n        total: canned_responses_category_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: canned_responses_category(limit: $limit, offset: $offset, order_by: $order_by, where: $where) {\n          id\n          name\n          language\n          is_enabled\n          created_at\n          updated_at\n          created_by {\n            name\n            id\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_All_CANNED_RESPONSE_CATEGORIES(\n        $limit: Int = 20\n        $offset: Int = 0\n        $order_by: [canned_responses_category_order_by!] = {}\n        $where: canned_responses_category_bool_exp = {}\n      ) {\n        total: canned_responses_category_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: canned_responses_category(limit: $limit, offset: $offset, order_by: $order_by, where: $where) {\n          id\n          name\n          language\n          is_enabled\n          created_at\n          updated_at\n          created_by {\n            name\n            id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_CANNED_CATEGORY($name: String!, $lang: String!) {\n        payload: insert_canned_responses_category_one(object: { name: $name, language: $lang }) {\n          id\n          language\n          name\n          is_enabled\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_CANNED_CATEGORY($name: String!, $lang: String!) {\n        payload: insert_canned_responses_category_one(object: { name: $name, language: $lang }) {\n          id\n          language\n          name\n          is_enabled\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_CANNED_CATEGORY_by_ID($id: bigint!, $updated_values: canned_responses_category_set_input = {}) {\n        payload: update_canned_responses_category_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n          is_enabled\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_CANNED_CATEGORY_by_ID($id: bigint!, $updated_values: canned_responses_category_set_input = {}) {\n        payload: update_canned_responses_category_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n          is_enabled\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_CANNED_CATEGORY_BY_ID($id: bigint!) {\n        payload: delete_canned_responses_category_by_pk(id: $id) {\n          id\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_CANNED_CATEGORY_BY_ID($id: bigint!) {\n        payload: delete_canned_responses_category_by_pk(id: $id) {\n          id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_CONTACTS($contact_id: Int!) {\n        payload: delete_contacts_by_pk(id: $contact_id) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_CONTACTS($contact_id: Int!) {\n        payload: delete_contacts_by_pk(id: $contact_id) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_CONTACT($id: Int!, $set: contacts_set_input = {}) {\n        payload: update_contacts_by_pk(pk_columns: { id: $id }, _set: $set) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          city\n          gender\n          preferred_language\n          social_profiles\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_CONTACT($id: Int!, $set: contacts_set_input = {}) {\n        payload: update_contacts_by_pk(pk_columns: { id: $id }, _set: $set) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          city\n          gender\n          preferred_language\n          social_profiles\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_CONVERSATION_STATUS($conversation_id: bigint!, $updated_status: conversations_set_input = {}) {\n        payload: update_conversations_by_pk(pk_columns: { id: $conversation_id }, _set: $updated_status) {\n          id\n          status\n          closing_contact_reason_value\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_CONVERSATION_STATUS($conversation_id: bigint!, $updated_status: conversations_set_input = {}) {\n        payload: update_conversations_by_pk(pk_columns: { id: $conversation_id }, _set: $updated_status) {\n          id\n          status\n          closing_contact_reason_value\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_CONVERSATION_TAG_BY_ID($tag_id: bigint!, $conversation_id: bigint!) {\n        payload: delete_conversation_tags(where: { tag_id: { _eq: $tag_id }, conversation_id: { _eq: $conversation_id } }) {\n          affected_rows\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_CONVERSATION_TAG_BY_ID($tag_id: bigint!, $conversation_id: bigint!) {\n        payload: delete_conversation_tags(where: { tag_id: { _eq: $tag_id }, conversation_id: { _eq: $conversation_id } }) {\n          affected_rows\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation SEND_NOTE_WITH_CONVERSATION_CLOSE($message: String = \"\", $message_type: Int = 10, $conversation_id: bigint = \"\") {\n        payload: insert_messages_one(object: { message: $message, message_type: $message_type, conversation_id: $conversation_id }) {\n          message\n          conversation {\n            id\n          }\n          message_type\n        }\n      }\n    "): (typeof documents)["\n      mutation SEND_NOTE_WITH_CONVERSATION_CLOSE($message: String = \"\", $message_type: Int = 10, $conversation_id: bigint = \"\") {\n        payload: insert_messages_one(object: { message: $message, message_type: $message_type, conversation_id: $conversation_id }) {\n          message\n          conversation {\n            id\n          }\n          message_type\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation ADD_TAG_TO_CONVERSATION($tag_id: bigint!, $conversation_id: bigint!) {\n        payload: insert_conversation_tags_one(\n          object: { tag_id: $tag_id, conversation_id: $conversation_id }\n          on_conflict: { constraint: conversation_tags_conversation_id_tag_id_key, update_columns: [] }\n        ) {\n          tag {\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation ADD_TAG_TO_CONVERSATION($tag_id: bigint!, $conversation_id: bigint!) {\n        payload: insert_conversation_tags_one(\n          object: { tag_id: $tag_id, conversation_id: $conversation_id }\n          on_conflict: { constraint: conversation_tags_conversation_id_tag_id_key, update_columns: [] }\n        ) {\n          tag {\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query FILTER_CONTACT_LIST($limit: Int = 20, $offset: Int = 0, $where: contacts_bool_exp = {}) {\n        counts: contacts_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: contacts(order_by: { id: desc }, limit: $limit, offset: $offset, where: $where) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          account_id\n          last_activity_at\n          social_profiles\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query FILTER_CONTACT_LIST($limit: Int = 20, $offset: Int = 0, $where: contacts_bool_exp = {}) {\n        counts: contacts_aggregate(where: $where) {\n          aggregate {\n            count\n          }\n        }\n        payload: contacts(order_by: { id: desc }, limit: $limit, offset: $offset, where: $where) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          account_id\n          last_activity_at\n          social_profiles\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONTACT_COUNT($offset: Int = 0, $where: contacts_bool_exp = {}) {\n        payload: contacts_aggregate(order_by: { id: desc }, offset: $offset, where: $where) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONTACT_COUNT($offset: Int = 0, $where: contacts_bool_exp = {}) {\n        payload: contacts_aggregate(order_by: { id: desc }, offset: $offset, where: $where) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query REPORT_CONVERSATION_COUNTS($date_range: timestamptz_comparison_exp = {}) {\n        total: conversations_aggregate(where: { updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        open: conversations_aggregate(where: { status: { _eq: 0 }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        assigned: conversations_aggregate(where: { agent_id: { _is_null: false }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: conversations_aggregate(where: { agent_id: { _is_null: true }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        closed: conversations_aggregate(where: { status: { _eq: 1 }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "): (typeof documents)["\n      query REPORT_CONVERSATION_COUNTS($date_range: timestamptz_comparison_exp = {}) {\n        total: conversations_aggregate(where: { updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        open: conversations_aggregate(where: { status: { _eq: 0 }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        assigned: conversations_aggregate(where: { agent_id: { _is_null: false }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: conversations_aggregate(where: { agent_id: { _is_null: true }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n        closed: conversations_aggregate(where: { status: { _eq: 1 }, updated_at: $date_range }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_AUTOMATION_RULES {\n        payload: automation_rules(order_by: { id: asc }) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "): (typeof documents)["\n      query GET_AUTOMATION_RULES {\n        payload: automation_rules(order_by: { id: asc }) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_AUTOMATION_RULES($object: automation_rules_insert_input = {}) {\n        payload: insert_automation_rules_one(object: $object) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_AUTOMATION_RULES($object: automation_rules_insert_input = {}) {\n        payload: insert_automation_rules_one(object: $object) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATED_AUTOMATION_RULES($id: bigint!, $_set: automation_rules_set_input = {}) {\n        payload: update_automation_rules_by_pk(pk_columns: { id: $id }, _set: $_set) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATED_AUTOMATION_RULES($id: bigint!, $_set: automation_rules_set_input = {}) {\n        payload: update_automation_rules_by_pk(pk_columns: { id: $id }, _set: $_set) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_AUTOMATION_RULES($id: bigint!) {\n        payload: delete_automation_rules_by_pk(id: $id) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_AUTOMATION_RULES($id: bigint!) {\n        payload: delete_automation_rules_by_pk(id: $id) {\n          id\n          name\n          description\n          event_name\n          conditions\n          actions\n          active\n          created_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_USER_STATUS($user_id: bigint!, $availability: Int!) {\n        payload: update_account_users(where: { user_id: { _eq: $user_id } }, _set: { availability: $availability }) {\n          affected_rows\n          returning {\n            user_id\n            availability\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_USER_STATUS($user_id: bigint!, $availability: Int!) {\n        payload: update_account_users(where: { user_id: { _eq: $user_id } }, _set: { availability: $availability }) {\n          affected_rows\n          returning {\n            user_id\n            availability\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_USER_STATUS($user_id: bigint!) {\n        payload: account_agents(where: { id: { _eq: $user_id } }) {\n          id\n          availability\n        }\n      }\n    "): (typeof documents)["\n      query GET_USER_STATUS($user_id: bigint!) {\n        payload: account_agents(where: { id: { _eq: $user_id } }) {\n          id\n          availability\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONTACT_BY_ID($id: Int!) {\n        payload: contacts_by_pk(id: $id) {\n          id\n          name\n          email\n          gender\n          city\n          profile_twitter\n          profile_instagram\n          preferred_language\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          last_activity_at\n          conversations {\n            id\n            account {\n              name\n            }\n            status\n            incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n              aggregate {\n                count\n              }\n            }\n            outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n              aggregate {\n                count\n              }\n            }\n            conversation_tags {\n              tag {\n                name\n              }\n            }\n            created_at\n            agent {\n              name\n            }\n            inbox {\n              channel_type\n            }\n          }\n          contact_tags {\n            tag {\n              id\n              color\n              name\n            }\n          }\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONTACT_BY_ID($id: Int!) {\n        payload: contacts_by_pk(id: $id) {\n          id\n          name\n          email\n          gender\n          city\n          profile_twitter\n          profile_instagram\n          preferred_language\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          last_activity_at\n          conversations {\n            id\n            account {\n              name\n            }\n            status\n            incoming: messages_aggregate(where: { message_type: { _eq: 0 } }) {\n              aggregate {\n                count\n              }\n            }\n            outgoing: messages_aggregate(where: { message_type: { _eq: 1 } }) {\n              aggregate {\n                count\n              }\n            }\n            conversation_tags {\n              tag {\n                name\n              }\n            }\n            created_at\n            agent {\n              name\n            }\n            inbox {\n              channel_type\n            }\n          }\n          contact_tags {\n            tag {\n              id\n              color\n              name\n            }\n          }\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONTACT_BY_PHONE_NUMBER($phone_number: String!) {\n        payload: contacts(where: { phone_number: { _eq: $phone_number } }) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          account_id\n          last_activity_at\n          social_profiles\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONTACT_BY_PHONE_NUMBER($phone_number: String!) {\n        payload: contacts(where: { phone_number: { _eq: $phone_number } }) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n          account_id\n          last_activity_at\n          social_profiles\n          total_conversations: conversations_aggregate(where: { inbox_id: { _is_null: false } }) {\n            aggregate {\n              count\n            }\n          }\n          total_tickets: tickets_aggregate {\n            aggregate {\n              count\n            }\n          }\n          total_csats: csat_feedbacks_aggregate {\n            aggregate {\n              count\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query TICKET_CONTACTS($search_contacts: String!) {\n        payload: contacts(\n          where: { _and: [{ _or: [{ name: { _ilike: $search_contacts } }, { email: { _ilike: $search_contacts } }, { phone_number: { _ilike: $search_contacts } }] }] }\n        ) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      query TICKET_CONTACTS($search_contacts: String!) {\n        payload: contacts(\n          where: { _and: [{ _or: [{ name: { _ilike: $search_contacts } }, { email: { _ilike: $search_contacts } }, { phone_number: { _ilike: $search_contacts } }] }] }\n        ) {\n          id\n          name\n          email\n          phone_number\n          profile_image: source(path: \"profile_image\")\n          source\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TICKET_FORM_LIST {\n        payload: ticket_forms {\n          id\n          type\n          description\n          enabled\n          survey_form\n          account_id\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      query GET_TICKET_FORM_LIST {\n        payload: ticket_forms {\n          id\n          type\n          description\n          enabled\n          survey_form\n          account_id\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TICKET_FORM_BY_ID($id: bigint!) {\n        payload: ticket_forms_by_pk(id: $id) {\n          id\n          survey_form\n          type\n          description\n        }\n      }\n    "): (typeof documents)["\n      query GET_TICKET_FORM_BY_ID($id: bigint!) {\n        payload: ticket_forms_by_pk(id: $id) {\n          id\n          survey_form\n          type\n          description\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_TICKET_FORM($object: ticket_forms_insert_input = {}) {\n        payload: insert_ticket_forms_one(object: $object) {\n          description\n          enabled\n          id\n          survey_form\n          type\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_TICKET_FORM($object: ticket_forms_insert_input = {}) {\n        payload: insert_ticket_forms_one(object: $object) {\n          description\n          enabled\n          id\n          survey_form\n          type\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_TICKET_FORM_BY_ID($id: bigint!, $survey_form: json = {}) {\n        payload: update_ticket_forms_by_pk(pk_columns: { id: $id }, _set: { survey_form: $survey_form }) {\n          id\n          updated_at\n          survey_form\n          type\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_TICKET_FORM_BY_ID($id: bigint!, $survey_form: json = {}) {\n        payload: update_ticket_forms_by_pk(pk_columns: { id: $id }, _set: { survey_form: $survey_form }) {\n          id\n          updated_at\n          survey_form\n          type\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_TICKET_FORM($id: bigint!) {\n        payload: delete_ticket_forms_by_pk(id: $id) {\n          id\n          type\n          description\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_TICKET_FORM($id: bigint!) {\n        payload: delete_ticket_forms_by_pk(id: $id) {\n          id\n          type\n          description\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TICKET_BY_ID($id: bigint!) {\n        payload: ticket_by_pk(id: $id) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          conversation_id\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n          contact {\n            id\n            name\n            email\n            phone_number\n            preferred_language\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n            social_profiles\n            conversations {\n              id\n              messages {\n                id\n                message\n              }\n            }\n          }\n          created_user {\n            name\n          }\n          ticket_shares {\n            team {\n              id\n              name\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TICKET_BY_ID($id: bigint!) {\n        payload: ticket_by_pk(id: $id) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          conversation_id\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n          contact {\n            id\n            name\n            email\n            phone_number\n            preferred_language\n            profile_image: source(path: \"profile_image\")\n            source\n            created_at\n            updated_at\n            social_profiles\n            conversations {\n              id\n              messages {\n                id\n                message\n              }\n            }\n          }\n          created_user {\n            name\n          }\n          ticket_shares {\n            team {\n              id\n              name\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation LINK_CONVERSATION_ID_TO_TICKET($conversationId: bigint!, $ticketId: bigint!) {\n        payload: update_ticket_by_pk(pk_columns: { id: $ticketId }, _set: { conversation_id: $conversationId }) {\n          conversation_id\n        }\n      }\n    "): (typeof documents)["\n      mutation LINK_CONVERSATION_ID_TO_TICKET($conversationId: bigint!, $ticketId: bigint!) {\n        payload: update_ticket_by_pk(pk_columns: { id: $ticketId }, _set: { conversation_id: $conversationId }) {\n          conversation_id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_TICKET($object: ticket_insert_input = {}) {\n        payload: insert_ticket_one(object: $object) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n          ticket_shares {\n            id\n            team_id\n            ticket_id\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_TICKET($object: ticket_insert_input = {}) {\n        payload: insert_ticket_one(object: $object) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n          ticket_shares {\n            id\n            team_id\n            ticket_id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_TICKET($ticket_id: Int!, $teams_id: [Int!], $ticket_share: [ticket_share_insert_input!] = {}, $id: bigint!, $_set: ticket_set_input = {}) {\n        delete_ticket_share(where: { ticket_id: { _eq: $ticket_id }, team_id: { _nin: $teams_id } }) {\n          returning {\n            id\n            team_id\n            ticket_id\n          }\n        }\n        insert_ticket_share(on_conflict: { constraint: ticket_share_ticket_id_team_id_key, update_columns: [] }, objects: $ticket_share) {\n          returning {\n            id\n            team_id\n            ticket_id\n          }\n        }\n        updated_ticket: update_ticket_by_pk(pk_columns: { id: $id }, _set: $_set) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_TICKET($ticket_id: Int!, $teams_id: [Int!], $ticket_share: [ticket_share_insert_input!] = {}, $id: bigint!, $_set: ticket_set_input = {}) {\n        delete_ticket_share(where: { ticket_id: { _eq: $ticket_id }, team_id: { _nin: $teams_id } }) {\n          returning {\n            id\n            team_id\n            ticket_id\n          }\n        }\n        insert_ticket_share(on_conflict: { constraint: ticket_share_ticket_id_team_id_key, update_columns: [] }, objects: $ticket_share) {\n          returning {\n            id\n            team_id\n            ticket_id\n          }\n        }\n        updated_ticket: update_ticket_by_pk(pk_columns: { id: $id }, _set: $_set) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_TICKET($id: bigint!) {\n        payload: delete_ticket_by_pk(id: $id) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_TICKET($id: bigint!) {\n        payload: delete_ticket_by_pk(id: $id) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TICKET_BY_CONTACT_ID($id: bigint!) {\n        payload: ticket(where: { contact_id: { _eq: $id } }) {\n          id\n          description\n          subject\n          source\n          status\n          priority\n          created_at\n          updated_at\n          type\n          form_value\n          assigned_agent\n          agent {\n            name\n          }\n          team {\n            name\n            id\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TICKET_BY_CONTACT_ID($id: bigint!) {\n        payload: ticket(where: { contact_id: { _eq: $id } }) {\n          id\n          description\n          subject\n          source\n          status\n          priority\n          created_at\n          updated_at\n          type\n          form_value\n          assigned_agent\n          agent {\n            name\n          }\n          team {\n            name\n            id\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TICKET_MESSAGES_BY_TICKET_ID($ticket_id: Int!, $cursor: Int_comparison_exp = {}) {\n        payload: ticket_messages(where: { ticket_id: { _eq: $ticket_id }, id: $cursor }, limit: 20, order_by: { id: desc }) {\n          id\n          message: content\n          content_attributes\n          message_type\n          internal\n          sender_info\n          status\n          source_id\n          created_at\n          ticket_id\n          attachments {\n            id\n            key\n            file_name\n            file_type\n            extension\n            url\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TICKET_MESSAGES_BY_TICKET_ID($ticket_id: Int!, $cursor: Int_comparison_exp = {}) {\n        payload: ticket_messages(where: { ticket_id: { _eq: $ticket_id }, id: $cursor }, limit: 20, order_by: { id: desc }) {\n          id\n          message: content\n          content_attributes\n          message_type\n          internal\n          sender_info\n          status\n          source_id\n          created_at\n          ticket_id\n          attachments {\n            id\n            key\n            file_name\n            file_type\n            extension\n            url\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n    subscription GET_TICKET_MESSAGES_SUBSCRIPTION($ticketId: Int!) {\n      payload: ticket_messages(where: { ticket_id: { _eq: $ticketId } }, limit: 1, order_by: { id: desc }) {\n        id\n      }\n    }\n  "): (typeof documents)["\n    subscription GET_TICKET_MESSAGES_SUBSCRIPTION($ticketId: Int!) {\n      payload: ticket_messages(where: { ticket_id: { _eq: $ticketId } }, limit: 1, order_by: { id: desc }) {\n        id\n      }\n    }\n  "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_SEARCHED_TICKETS($where: ticket_bool_exp) {\n        payload: ticket(where: $where) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_SEARCHED_TICKETS($where: ticket_bool_exp) {\n        payload: ticket(where: $where) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_FILTERED_TICKETS($offset: Int = 0, $where: ticket_bool_exp = {}, $id: order_by) {\n        payload: ticket(order_by: { id: $id }, limit: 10, offset: $offset, where: $where) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_FILTERED_TICKETS($offset: Int = 0, $where: ticket_bool_exp = {}, $id: order_by) {\n        payload: ticket(order_by: { id: $id }, limit: 10, offset: $offset, where: $where) {\n          id\n          form_value\n          created_at\n          contact_id\n          assigned_agent\n          account_id\n          type\n          priority\n          resolution_time\n          status\n          subject\n          assigned_team\n          ticket_form_id\n          updated_at\n          description\n          created_by\n          source\n          team {\n            id\n            name\n          }\n          agent {\n            id\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n    subscription GET_TICKET_COUNT_SUBSCRIPTION($where: ticket_bool_exp = {}) {\n      payload: ticket_aggregate(where: $where) {\n        aggregate {\n          count\n        }\n      }\n    }\n  "): (typeof documents)["\n    subscription GET_TICKET_COUNT_SUBSCRIPTION($where: ticket_bool_exp = {}) {\n      payload: ticket_aggregate(where: $where) {\n        aggregate {\n          count\n        }\n      }\n    }\n  "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n    subscription GET_TICKETS_SUBSCRIPTION($where: ticket_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc, $offset1: Int = 10, $created_at1: order_by = asc) {\n      ticket(where: $where, offset: $offset1, limit: 1, order_by: { messages_aggregate: { max: { created_at: $created_at1 } } }) {\n        id\n      }\n    }\n  "): (typeof documents)["\n    subscription GET_TICKETS_SUBSCRIPTION($where: ticket_bool_exp = {}, $offset: Int = 0, $created_at: order_by = desc, $offset1: Int = 10, $created_at1: order_by = asc) {\n      ticket(where: $where, offset: $offset1, limit: 1, order_by: { messages_aggregate: { max: { created_at: $created_at1 } } }) {\n        id\n      }\n    }\n  "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TICKETS_COUNTS($_and: [ticket_bool_exp!] = {}) {\n        mine: ticket_aggregate(where: { tab_type: { _contains: \"mine\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        team: ticket_aggregate(where: { tab_type: { _contains: \"team\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        watching: ticket_aggregate(where: { tab_type: { _contains: \"watching\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        history: ticket_aggregate(where: { tab_type: { _has_keys_any: [\"history\", \"shared\"] }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: ticket_aggregate(where: { tab_type: { _contains: \"unassigned\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TICKETS_COUNTS($_and: [ticket_bool_exp!] = {}) {\n        mine: ticket_aggregate(where: { tab_type: { _contains: \"mine\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        team: ticket_aggregate(where: { tab_type: { _contains: \"team\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        watching: ticket_aggregate(where: { tab_type: { _contains: \"watching\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        history: ticket_aggregate(where: { tab_type: { _has_keys_any: [\"history\", \"shared\"] }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n        unassigned: ticket_aggregate(where: { tab_type: { _contains: \"unassigned\" }, _and: $_and }) {\n          aggregate {\n            count\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_CONTACT($contact_values: contacts_insert_input = {}) {\n        payload: insert_contacts_one(object: $contact_values) {\n          id\n          name\n          email\n          phone_number\n          gender\n          city\n          preferred_language\n          profile_twitter\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_CONTACT($contact_values: contacts_insert_input = {}) {\n        payload: insert_contacts_one(object: $contact_values) {\n          id\n          name\n          email\n          phone_number\n          gender\n          city\n          preferred_language\n          profile_twitter\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_PHONE_NUMBER($id: Int!, $set: String!) {\n        payload: update_contacts_by_pk(pk_columns: { id: $id }, _set: { phone_number: $set }) {\n          id\n          phone_number\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_PHONE_NUMBER($id: Int!, $set: String!) {\n        payload: update_contacts_by_pk(pk_columns: { id: $id }, _set: { phone_number: $set }) {\n          id\n          phone_number\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TWITTER_CHANNEL_PROFILES {\n        payload: channel_twitter_profiles {\n          id\n          screen_name\n        }\n      }\n    "): (typeof documents)["\n      query GET_TWITTER_CHANNEL_PROFILES {\n        payload: channel_twitter_profiles {\n          id\n          screen_name\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query USER_PROFILE_INFO($id: bigint!) {\n        payload: users_by_pk(id: $id) {\n          availability\n          email\n          display_name\n          id\n          hr_id\n          name\n          phone_number\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      query USER_PROFILE_INFO($id: bigint!) {\n        payload: users_by_pk(id: $id) {\n          availability\n          email\n          display_name\n          id\n          hr_id\n          name\n          phone_number\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GetAllPublishArticles($limit: Int = 20, $offset: Int = 0) {\n        payload: knowledge_base_articles(limit: $limit, offset: $offset, where: { article_status: { _eq: \"published\" } }) {\n          id\n          name\n          body\n          language\n          article_status\n          category {\n            name\n            id\n          }\n        }\n        total: knowledge_base_articles_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GetAllPublishArticles($limit: Int = 20, $offset: Int = 0) {\n        payload: knowledge_base_articles(limit: $limit, offset: $offset, where: { article_status: { _eq: \"published\" } }) {\n          id\n          name\n          body\n          language\n          article_status\n          category {\n            name\n            id\n          }\n        }\n        total: knowledge_base_articles_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_PUBLISHED_ARTICLES_BY_ID($id: bigint = \"\") {\n        payload: knowledge_base_articles_by_pk(id: $id) {\n          id\n          name\n          updated_at\n          body\n          meta_tags\n          meta_description\n          language\n          category {\n            id\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_PUBLISHED_ARTICLES_BY_ID($id: bigint = \"\") {\n        payload: knowledge_base_articles_by_pk(id: $id) {\n          id\n          name\n          updated_at\n          body\n          meta_tags\n          meta_description\n          language\n          category {\n            id\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_ALL_PUBLISHED_ARTICLES_BY_CATEGORIES($categories: String!) {\n        payload: knowledge_base_articles(where: { article_status: { _eq: \"published\" }, _and: { category: { name: { _eq: $categories } } } }) {\n          id\n          name\n          article_status\n          body\n          category {\n            id\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_ALL_PUBLISHED_ARTICLES_BY_CATEGORIES($categories: String!) {\n        payload: knowledge_base_articles(where: { article_status: { _eq: \"published\" }, _and: { category: { name: { _eq: $categories } } } }) {\n          id\n          name\n          article_status\n          body\n          category {\n            id\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_USER_PROFILE_BY_ID($id: bigint!, $updated_values: users_set_input = {}) {\n        payload: update_users_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          name\n          display_name\n          email\n          phone_number\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_USER_PROFILE_BY_ID($id: bigint!, $updated_values: users_set_input = {}) {\n        payload: update_users_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          name\n          display_name\n          email\n          phone_number\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_KNOWLEDGE_BASE_CATEGORY($object: knowledge_base_categories_insert_input = {}) {\n        payload: insert_knowledge_base_categories_one(object: $object) {\n          id\n          name\n          language\n          description\n          updated_at\n          is_enabled\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_KNOWLEDGE_BASE_CATEGORY($object: knowledge_base_categories_insert_input = {}) {\n        payload: insert_knowledge_base_categories_one(object: $object) {\n          id\n          name\n          language\n          description\n          updated_at\n          is_enabled\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_ALL_KNOWLEDGE_BASE_CATEGORIES {\n        total: knowledge_base_categories_aggregate {\n          aggregate {\n            count\n          }\n        }\n        payload: knowledge_base_categories(order_by: { id: asc }) {\n          id\n          name\n          description\n          language\n          is_enabled\n          created_by {\n            name\n          }\n          updated_at\n          created_at\n        }\n      }\n    "): (typeof documents)["\n      query GET_ALL_KNOWLEDGE_BASE_CATEGORIES {\n        total: knowledge_base_categories_aggregate {\n          aggregate {\n            count\n          }\n        }\n        payload: knowledge_base_categories(order_by: { id: asc }) {\n          id\n          name\n          description\n          language\n          is_enabled\n          created_by {\n            name\n          }\n          updated_at\n          created_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CATEGORIES_BY_ID($id: bigint = \"\") {\n        payload: knowledge_base_categories_by_pk(id: $id) {\n          id\n          name\n          language\n          description\n        }\n      }\n    "): (typeof documents)["\n      query GET_CATEGORIES_BY_ID($id: bigint = \"\") {\n        payload: knowledge_base_categories_by_pk(id: $id) {\n          id\n          name\n          language\n          description\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_KNOWLEDGE_BASE_CATEGORIES_BY_ID($id: bigint!, $updated_values: knowledge_base_categories_set_input = {}) {\n        payload: update_knowledge_base_categories_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_KNOWLEDGE_BASE_CATEGORIES_BY_ID($id: bigint!, $updated_values: knowledge_base_categories_set_input = {}) {\n        payload: update_knowledge_base_categories_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_KNOWLEDGE_BASE_CATEGORY_BY_ID($id: bigint!) {\n        payload: delete_knowledge_base_categories_by_pk(id: $id) {\n          id\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_KNOWLEDGE_BASE_CATEGORY_BY_ID($id: bigint!) {\n        payload: delete_knowledge_base_categories_by_pk(id: $id) {\n          id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_ALL_KNOWLEDGE_BASE_ARTICLES($search_content: String = \"\", $offset: Int = 0) {\n        total: knowledge_base_articles_aggregate(\n          where: { _or: [{ name: { _ilike: $search_content } }, { body: { _ilike: $search_content } }] }\n          offset: $offset\n          order_by: { id: asc }\n        ) {\n          aggregate {\n            count\n          }\n        }\n        payload: knowledge_base_articles(where: { _or: [{ name: { _ilike: $search_content } }, { body: { _ilike: $search_content } }] }, offset: $offset, order_by: { id: asc }) {\n          id\n          name\n          body\n          article_status\n          permissions\n          read_count\n          is_enabled\n          language\n          meta_tags\n          meta_description\n          conversation_trigger\n          category_id\n          created_by {\n            name\n          }\n          created_at\n          updated_at\n          category {\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_ALL_KNOWLEDGE_BASE_ARTICLES($search_content: String = \"\", $offset: Int = 0) {\n        total: knowledge_base_articles_aggregate(\n          where: { _or: [{ name: { _ilike: $search_content } }, { body: { _ilike: $search_content } }] }\n          offset: $offset\n          order_by: { id: asc }\n        ) {\n          aggregate {\n            count\n          }\n        }\n        payload: knowledge_base_articles(where: { _or: [{ name: { _ilike: $search_content } }, { body: { _ilike: $search_content } }] }, offset: $offset, order_by: { id: asc }) {\n          id\n          name\n          body\n          article_status\n          permissions\n          read_count\n          is_enabled\n          language\n          meta_tags\n          meta_description\n          conversation_trigger\n          category_id\n          created_by {\n            name\n          }\n          created_at\n          updated_at\n          category {\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_KNOWLEDGE_BASE_ARTICLE($object: knowledge_base_articles_insert_input = {}) {\n        payload: insert_knowledge_base_articles_one(object: $object) {\n          id\n          name\n          body\n          read_count\n          permissions\n          language\n          is_enabled\n          created_at\n          updated_at\n          article_status\n          conversation_trigger\n          meta_description\n          meta_tags\n          created_by {\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_KNOWLEDGE_BASE_ARTICLE($object: knowledge_base_articles_insert_input = {}) {\n        payload: insert_knowledge_base_articles_one(object: $object) {\n          id\n          name\n          body\n          read_count\n          permissions\n          language\n          is_enabled\n          created_at\n          updated_at\n          article_status\n          conversation_trigger\n          meta_description\n          meta_tags\n          created_by {\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_SPECIFIC_ARTICLE_BY_ID($id: bigint!) {\n        payload: knowledge_base_articles_by_pk(id: $id) {\n          id\n          name\n          body\n          article_status\n          permissions\n          read_count\n          is_enabled\n          language\n          meta_tags\n          meta_description\n          conversation_trigger\n          category_id\n          created_by {\n            name\n          }\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      query GET_SPECIFIC_ARTICLE_BY_ID($id: bigint!) {\n        payload: knowledge_base_articles_by_pk(id: $id) {\n          id\n          name\n          body\n          article_status\n          permissions\n          read_count\n          is_enabled\n          language\n          meta_tags\n          meta_description\n          conversation_trigger\n          category_id\n          created_by {\n            name\n          }\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_ARTICLE_BY_ID($id: bigint = \"\", $updated_values: knowledge_base_articles_set_input = {}, $read_count: Int = 1) {\n        payload: update_knowledge_base_articles_by_pk(pk_columns: { id: $id }, _set: $updated_values, _inc: { read_count: $read_count }) {\n          id\n          name\n          read_count\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_ARTICLE_BY_ID($id: bigint = \"\", $updated_values: knowledge_base_articles_set_input = {}, $read_count: Int = 1) {\n        payload: update_knowledge_base_articles_by_pk(pk_columns: { id: $id }, _set: $updated_values, _inc: { read_count: $read_count }) {\n          id\n          name\n          read_count\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_ARTICLE_BY_ID($id: bigint = \"\") {\n        payload: delete_knowledge_base_articles_by_pk(id: $id) {\n          id\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_ARTICLE_BY_ID($id: bigint = \"\") {\n        payload: delete_knowledge_base_articles_by_pk(id: $id) {\n          id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation CREATE_TAG($object: tags_insert_input = {}) {\n        payload: insert_tags_one(object: $object) {\n          id\n          name\n          description\n          level\n        }\n      }\n    "): (typeof documents)["\n      mutation CREATE_TAG($object: tags_insert_input = {}) {\n        payload: insert_tags_one(object: $object) {\n          id\n          name\n          description\n          level\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_ALL_TAGS($search_items: String!) {\n        total: tags_aggregate {\n          aggregate {\n            count\n          }\n        }\n        payload: tags(where: { _or: [{ name: { _ilike: $search_items } }, { description: { _ilike: $search_items } }] }, order_by: { id: asc }) {\n          id\n          name\n          description\n          is_enabled\n          level\n          created_at\n          updated_at\n          smart_tags\n          account_id\n          created_by {\n            id\n            name\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_ALL_TAGS($search_items: String!) {\n        total: tags_aggregate {\n          aggregate {\n            count\n          }\n        }\n        payload: tags(where: { _or: [{ name: { _ilike: $search_items } }, { description: { _ilike: $search_items } }] }, order_by: { id: asc }) {\n          id\n          name\n          description\n          is_enabled\n          level\n          created_at\n          updated_at\n          smart_tags\n          account_id\n          created_by {\n            id\n            name\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_A_TAG_BY_ID($id: bigint = \"\") {\n        payload: tags_by_pk(id: $id) {\n          id\n          name\n          description\n          level\n          smart_tags\n        }\n      }\n    "): (typeof documents)["\n      query GET_A_TAG_BY_ID($id: bigint = \"\") {\n        payload: tags_by_pk(id: $id) {\n          id\n          name\n          description\n          level\n          smart_tags\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATED_TAGS($updated_values: tags_set_input = {}, $id: bigint = \"\") {\n        payload: update_tags_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATED_TAGS($updated_values: tags_set_input = {}, $id: bigint = \"\") {\n        payload: update_tags_by_pk(pk_columns: { id: $id }, _set: $updated_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation DELETE_TAG_BY_ID($id: bigint!) {\n        payload: delete_tags_by_pk(id: $id) {\n          id\n          name\n          description\n          level\n          is_enabled\n          created_at\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      mutation DELETE_TAG_BY_ID($id: bigint!) {\n        payload: delete_tags_by_pk(id: $id) {\n          id\n          name\n          description\n          level\n          is_enabled\n          created_at\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATED_CONTACT_REASON_BY_ID($id: bigint = \"\", $categories: jsonb = \"\") {\n        payload: update_workflows_contact_reason_by_pk(pk_columns: { id: $id }, _set: { categories: $categories }) {\n          id\n          updated_at\n          contact_reason\n          categories\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATED_CONTACT_REASON_BY_ID($id: bigint = \"\", $categories: jsonb = \"\") {\n        payload: update_workflows_contact_reason_by_pk(pk_columns: { id: $id }, _set: { categories: $categories }) {\n          id\n          updated_at\n          contact_reason\n          categories\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_ALL_CONTACT_REASONS {\n        payload: workflows_contact_reason {\n          categories\n          contact_reason\n          created_at\n          id\n          updated_at\n        }\n      }\n    "): (typeof documents)["\n      query GET_ALL_CONTACT_REASONS {\n        payload: workflows_contact_reason {\n          categories\n          contact_reason\n          created_at\n          id\n          updated_at\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_LAST_ACTIVE_AT($user_id: bigint!) {\n        payload: update_account_users(where: { user_id: { _eq: $user_id } }, _set: { last_active_at: \"now()\" }) {\n          returning {\n            user_id\n            last_active_at\n          }\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_LAST_ACTIVE_AT($user_id: bigint!) {\n        payload: update_account_users(where: { user_id: { _eq: $user_id } }, _set: { last_active_at: \"now()\" }) {\n          returning {\n            user_id\n            last_active_at\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation ADD_AGENT($object: account_users_insert_input!) {\n        payload: insert_account_users_one(object: $object, on_conflict: { constraint: account_users_account_id_user_id_key, update_columns: [] }) {\n          id\n          user_id\n        }\n      }\n    "): (typeof documents)["\n      mutation ADD_AGENT($object: account_users_insert_input!) {\n        payload: insert_account_users_one(object: $object, on_conflict: { constraint: account_users_account_id_user_id_key, update_columns: [] }) {\n          id\n          user_id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CONVERSATION_CSAT($csat_id: String!) {\n        payload: conversations(where: { csat_id: { _eq: $csat_id } }) {\n          id\n          contact_id\n          csat_sent\n          csat_sent_at\n          csat_language\n          csat_feedback {\n            satisfaction_point\n            open_question_ans\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CONVERSATION_CSAT($csat_id: String!) {\n        payload: conversations(where: { csat_id: { _eq: $csat_id } }) {\n          id\n          contact_id\n          csat_sent\n          csat_sent_at\n          csat_language\n          csat_feedback {\n            satisfaction_point\n            open_question_ans\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_TICKET_CSAT($csat_id: String!) {\n        payload: ticket(where: { csat_id: { _eq: $csat_id } }) {\n          id\n          contact_id\n          csat_sent\n          csat_sent_at\n          csat_language\n          csat_feedback {\n            satisfaction_point\n            open_question_ans\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_TICKET_CSAT($csat_id: String!) {\n        payload: ticket(where: { csat_id: { _eq: $csat_id } }) {\n          id\n          contact_id\n          csat_sent\n          csat_sent_at\n          csat_language\n          csat_feedback {\n            satisfaction_point\n            open_question_ans\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation ADD_CSAT_FEEDBACK($object: csat_feedback_insert_input!) {\n        payload: insert_csat_feedback_one(object: $object) {\n          contact_id\n          conversation_id\n          ticket_id\n          satisfaction_point\n          open_question_ans\n        }\n      }\n    "): (typeof documents)["\n      mutation ADD_CSAT_FEEDBACK($object: csat_feedback_insert_input!) {\n        payload: insert_csat_feedback_one(object: $object) {\n          contact_id\n          conversation_id\n          ticket_id\n          satisfaction_point\n          open_question_ans\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_CSAT_SCORE($where: csat_feedback_bool_exp = {}) {\n        feedback: csat_feedback(where: $where) {\n          satisfaction_point\n          open_question_ans\n          conversation_id\n          ticket_id\n        }\n        aggregations: csat_feedback_aggregate(where: $where) {\n          aggregate {\n            count\n            sum {\n              satisfaction_point\n            }\n          }\n        }\n      }\n    "): (typeof documents)["\n      query GET_CSAT_SCORE($where: csat_feedback_bool_exp = {}) {\n        feedback: csat_feedback(where: $where) {\n          satisfaction_point\n          open_question_ans\n          conversation_id\n          ticket_id\n        }\n        aggregations: csat_feedback_aggregate(where: $where) {\n          aggregate {\n            count\n            sum {\n              satisfaction_point\n            }\n          }\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      query GET_INSTAGRAM_PAGES {\n        payload: channel_instagram {\n          page_id\n        }\n      }\n    "): (typeof documents)["\n      query GET_INSTAGRAM_PAGES {\n        payload: channel_instagram {\n          page_id\n        }\n      }\n    "];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "\n      mutation UPDATE_INSTAGRAM_INBOX_BY_ID($inbox_id: Int!, $inbox_update_values: inboxes_set_input = {}) {\n        payload: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n      }\n    "): (typeof documents)["\n      mutation UPDATE_INSTAGRAM_INBOX_BY_ID($inbox_id: Int!, $inbox_update_values: inboxes_set_input = {}) {\n        payload: update_inboxes_by_pk(pk_columns: { id: $inbox_id }, _set: $inbox_update_values) {\n          id\n          name\n          description\n          is_enabled\n        }\n      }\n    "];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;